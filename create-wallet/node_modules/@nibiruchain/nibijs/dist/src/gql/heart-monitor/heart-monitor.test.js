"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ws_1 = require("ws");
const __1 = require("..");
const nibiruUrl = "testnet-1";
const heartMonitor = new __1.HeartMonitor(`https://hm-graphql.${nibiruUrl}.nibiru.fi/query`, `wss://hm-graphql.${nibiruUrl}.nibiru.fi/query`, ws_1.WebSocket);
afterAll(() => __awaiter(void 0, void 0, void 0, function* () {
    yield heartMonitor.closeWebSocket();
}));
describe("Heart Monitor constructor", () => {
    const { defaultGqlEndpt } = new __1.HeartMonitor();
    const tests = [
        { name: "undefined", in: undefined, expected: defaultGqlEndpt },
        { name: "valid string", in: "abc123", expected: "abc123" },
    ];
    test.each(tests)("$name", (tc) => {
        const hm = new __1.HeartMonitor(tc.in, `wss://hm-graphql.${nibiruUrl}.nibiru.fi/query`);
        expect(hm.gqlEndpt).toBe(tc.expected);
    });
});
const testCommunityPool = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c;
    const resp = yield heartMonitor.communityPool(args, fields);
    expect(resp).toHaveProperty("communityPool");
    if (((_b = (_a = resp.communityPool) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0) {
        const [communityPool] = (_c = resp.communityPool) !== null && _c !== void 0 ? _c : [];
        (0, __1.checkFields)([communityPool], ["amount", "denom"]);
    }
});
test("communityPool", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testCommunityPool({}, __1.defaultToken);
}));
const testDistributionCommissions = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    var _d, _e, _f;
    const resp = yield heartMonitor.distributionCommissions(args, fields);
    expect(resp).toHaveProperty("distributionCommissions");
    if (((_e = (_d = resp.distributionCommissions) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0) > 0) {
        const [distributionCommissions] = (_f = resp.distributionCommissions) !== null && _f !== void 0 ? _f : [];
        (0, __1.checkFields)([distributionCommissions], ["commission", "validator"]);
    }
});
test("distributionCommissions", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testDistributionCommissions({ limit: 1 }, __1.defaultDistributionCommission);
    yield testDistributionCommissions({}, __1.defaultDistributionCommission);
}));
const testFeatureFlags = (fields) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield heartMonitor.featureFlags(fields);
    expect(resp).toHaveProperty("featureFlags");
    if (resp.featureFlags) {
        const { featureFlags } = resp;
        (0, __1.checkFields)([featureFlags], ["gov", "oracle", "perp", "spot", "staking", "wasm"]);
    }
});
test("featureFlags", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testFeatureFlags(__1.defaultFeatureFlags);
}));
const testGovernance = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield heartMonitor.governance(args, fields);
    expect(resp).toHaveProperty("governance");
    if (resp.governance) {
        const { governance } = resp;
        (0, __1.checkFields)([governance], ["govDeposits", "govProposals", "govVotes"]);
    }
});
test.skip("governance", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testGovernance({
        govDeposits: {
            limit: 1,
        },
        govProposals: {
            limit: 1,
        },
        govVotes: {
            limit: 1,
        },
    }, {
        govDeposits: __1.defaultGovDeposit,
        govProposals: __1.defaultGovProposal,
        govVotes: __1.defaultGovVote,
    });
    yield testGovernance({}, {
        govDeposits: __1.defaultGovDeposit,
        govProposals: __1.defaultGovProposal,
        govVotes: __1.defaultGovVote,
    });
}));
const testIbc = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield heartMonitor.ibc(args, fields);
    expect(resp).toHaveProperty("ibc");
    if (resp.ibc) {
        const { ibc } = resp;
        (0, __1.checkFields)([ibc], [...(args.ibcChannels ? ["ibcChannels"] : []), "ibcTransfers"]);
    }
});
test("ibc", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testIbc({
        ibcChannels: undefined,
        ibcTransfers: {
            limit: 1,
        },
    }, {
        ibcChannels: __1.defaultIbcChannelsResponse,
        ibcTransfers: __1.defaultIbcTransfer,
    });
    yield testIbc({}, {
        ibcChannels: __1.defaultIbcChannelsResponse,
        ibcTransfers: __1.defaultIbcTransfer,
    });
}));
const testInflation = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield heartMonitor.inflation(args, fields);
    expect(resp).toHaveProperty("inflation");
    if (resp.inflation) {
        const { inflation } = resp;
        (0, __1.checkFields)([inflation], ["distributions", "inflations", ...(fields.rewards ? ["rewards"] : [])]);
    }
});
test("inflation", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testInflation({}, {
        inflations: __1.defaultInflationInfo,
        distributions: __1.defaultInflationDistribution,
        rewards: __1.defaultInflationReward,
    });
}));
const testOracle = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield heartMonitor.oracle(args, fields);
    expect(resp).toHaveProperty("oracle");
    if (resp.oracle) {
        const { oracle } = resp;
        (0, __1.checkFields)([oracle], ["oraclePrices", "oracles"]);
    }
});
const testMarkPriceCandles = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    var _g, _h, _j;
    const resp = yield heartMonitor.markPriceCandles(args, fields);
    expect(resp).toHaveProperty("markPriceCandles");
    if (((_h = (_g = resp.markPriceCandles) === null || _g === void 0 ? void 0 : _g.length) !== null && _h !== void 0 ? _h : 0) > 0) {
        const [markPriceCandle] = (_j = resp.markPriceCandles) !== null && _j !== void 0 ? _j : [];
        (0, __1.checkFields)([markPriceCandle], ["close", "high", "low", "open", "pair", "period", "periodStartTs"]);
    }
});
test.skip("markPriceCandles", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testMarkPriceCandles({}, __1.defaultMarkPriceCandles);
}));
test.skip("markPriceCandlesSubscription undefined client", () => __awaiter(void 0, void 0, void 0, function* () {
    const hm = new __1.HeartMonitor(`https://hm-graphql.${nibiruUrl}.nibiru.fi/query`);
    const resp = yield hm.markPriceCandlesSubscription({
        where: {
            pairEq: "ubtc:unusd",
            periodEq: 100000000,
        },
        limit: 1,
    }, __1.defaultMarkPriceCandles);
    expect(resp).toBeUndefined();
}));
const testMarkPriceCandlesSubscription = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    var _k, _l;
    const resp = yield heartMonitor.markPriceCandlesSubscription(args, fields);
    const event = yield (resp === null || resp === void 0 ? void 0 : resp.next());
    expect(event === null || event === void 0 ? void 0 : event.value.data).toHaveProperty("markPriceCandles");
    if (((_k = event === null || event === void 0 ? void 0 : event.value.data.markPriceCandles.length) !== null && _k !== void 0 ? _k : 0) > 0) {
        const [markPriceCandle] = (_l = event === null || event === void 0 ? void 0 : event.value.data.markPriceCandles) !== null && _l !== void 0 ? _l : [];
        (0, __1.checkFields)([markPriceCandle], ["close", "high", "low", "open", "pair", "period", "periodStartTs"]);
    }
});
test.skip("markPriceCandlesSubscription", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testMarkPriceCandlesSubscription({
        limit: 1,
        where: {
            pairEq: "ubtc:unusd",
            periodEq: 100000000,
        },
    }, __1.defaultMarkPriceCandles);
}));
test("oracle", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testOracle({
        oraclePrices: {
            limit: 1,
        },
        oracles: {
            limit: 1,
        },
    }, {
        oraclePrices: __1.defaultOraclePrice,
        oracles: __1.defaultOracleEntry,
    });
    yield testOracle({}, {
        oraclePrices: __1.defaultOraclePrice,
        oracles: __1.defaultOracleEntry,
    });
}));
test("oraclePricesSubscription undefined client", () => __awaiter(void 0, void 0, void 0, function* () {
    const hm = new __1.HeartMonitor(`https://hm-graphql.${nibiruUrl}.nibiru.fi/query`);
    const resp = yield hm.oraclePricesSubscription({
        where: { pair: "ubtc:unusd" },
    }, __1.defaultOraclePrice);
    expect(resp).toBeUndefined();
}));
const testOraclePricesSubscription = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    var _m, _o;
    const resp = yield heartMonitor.oraclePricesSubscription(args, fields);
    const event = yield (resp === null || resp === void 0 ? void 0 : resp.next());
    expect(event === null || event === void 0 ? void 0 : event.value.data).toHaveProperty("oraclePrices");
    if (((_m = event === null || event === void 0 ? void 0 : event.value.data.oraclePrices.length) !== null && _m !== void 0 ? _m : 0) > 0) {
        const [oraclePrices] = (_o = event === null || event === void 0 ? void 0 : event.value.data.oraclePrices) !== null && _o !== void 0 ? _o : [];
        (0, __1.checkFields)([oraclePrices], ["block", "pair", "price"]);
    }
});
test.skip("oraclePricesSubscription", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testOraclePricesSubscription({
        where: { pair: "ubtc:unusd" },
    }, __1.defaultOraclePrice);
}));
const testPerp = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield heartMonitor.perp(args, fields);
    expect(resp).toHaveProperty("perp");
    if (resp.GQLPerp) {
        const { GQLPerp } = resp;
        (0, __1.checkFields)([GQLPerp], [
            "leaderboard",
            "market",
            "markets",
            "position",
            "positionChanges",
            "positions",
        ]);
    }
});
test.skip("perp", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testPerp({
        leaderboard: {
            limit: 1,
        },
        market: {
            where: {
                pair: "ubtc:unusd",
            },
        },
        markets: {
            limit: 1,
        },
        position: {
            where: {
                pair: "ubtc:unusd",
                trader_address: "nibi1judn9xtel563nmq0ghpvmkqvyd5wnkm30mvkk3",
            },
        },
        positions: {
            limit: 1,
        },
        positionChanges: {
            limit: 1,
            where: {
                traderAddressEq: "nibi1judn9xtel563nmq0ghpvmkqvyd5wnkm30mvkk3",
            },
        },
    }, {
        leaderboard: __1.defaultPerpLeaderboard,
        market: __1.defaultPerpMarket,
        markets: __1.defaultPerpMarket,
        position: __1.defaultPerpPosition,
        positions: __1.defaultPerpPosition,
        positionChanges: __1.defaultPerpPositionChanges,
    });
    // Note: This is because market and position do not exist
    const resp = yield heartMonitor.perp({}, {
        leaderboard: __1.defaultPerpLeaderboard,
        markets: __1.defaultPerpMarket,
        positions: __1.defaultPerpPosition,
    });
    expect(resp).toHaveProperty("perp");
    if (resp.GQLPerp) {
        const { GQLPerp } = resp;
        (0, __1.checkFields)([GQLPerp], ["leaderboard", "markets", "positions"]);
    }
}));
test("perpMarketSubscription undefined client", () => __awaiter(void 0, void 0, void 0, function* () {
    const hm = new __1.HeartMonitor(`https://hm-graphql.${nibiruUrl}.nibiru.fi/query`);
    const resp = yield hm.perpMarketSubscription({
        where: { pair: "ubtc:unusd" },
    }, __1.defaultPerpMarket);
    expect(resp).toBeUndefined();
}));
const testPerpMarketSubscription = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield heartMonitor.perpMarketSubscription(args, fields);
    const event = yield (resp === null || resp === void 0 ? void 0 : resp.next());
    expect(event === null || event === void 0 ? void 0 : event.value.data).toHaveProperty("perpMarket");
    if (event === null || event === void 0 ? void 0 : event.value.data.perpMarket) {
        const { perpMarket } = event.value.data;
        (0, __1.checkFields)([perpMarket], [
            "pair",
            "enabled",
            "maintenance_margin_ratio",
            "max_leverage",
            "latest_cumulative_premium_fraction",
            "exchange_fee_ratio",
            "ecosystem_fund_fee_ratio",
            "max_funding_rate",
            "liquidation_fee_ratio",
            "partial_liquidation_ratio",
            "funding_rate_epoch_id",
            "twap_lookback_window",
            "prepaid_bad_debt",
            "base_reserve",
            "quote_reserve",
            "sqrt_depth",
            "price_multiplier",
            "total_long",
            "total_short",
            "mark_price",
            "mark_price_twap",
            "index_price_twap",
            "is_deleted",
        ]);
    }
});
test.skip("perpMarketSubscription", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testPerpMarketSubscription({
        where: { pair: "ubtc:unusd" },
    }, __1.defaultPerpMarket);
}));
test("perpPositionsSubscription undefined client", () => __awaiter(void 0, void 0, void 0, function* () {
    const hm = new __1.HeartMonitor(`https://hm-graphql.${nibiruUrl}.nibiru.fi/query`);
    const resp = yield hm.perpPositionsSubscription({
        where: {
            pair: "ubtc:unusd",
            trader_address: "nibi14garegtvsx3zcku4esd30xd2pze7ck44ysxeg3",
        },
    }, __1.defaultPerpPosition);
    expect(resp).toBeUndefined();
}));
const testPerpPositionsSubscription = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    var _p, _q;
    const resp = yield heartMonitor.perpPositionsSubscription(args, fields);
    const event = yield (resp === null || resp === void 0 ? void 0 : resp.next());
    expect(event === null || event === void 0 ? void 0 : event.value.data).toHaveProperty("perpPositions");
    if (((_p = event === null || event === void 0 ? void 0 : event.value.data.perpPositions.length) !== null && _p !== void 0 ? _p : 0) > 0) {
        const [perpPositions] = (_q = event === null || event === void 0 ? void 0 : event.value.data.perpPositions) !== null && _q !== void 0 ? _q : [];
        (0, __1.checkFields)([perpPositions], [
            "pair",
            "trader_address",
            "size",
            "margin",
            "open_notional",
            "position_notional",
            "latest_cumulative_premium_fraction",
            "unrealized_pnl",
            "unrealized_funding_payment",
            "margin_ratio",
            "bad_debt",
            "last_updated_block",
        ]);
    }
});
test.skip("perpPositionsSubscription", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testPerpPositionsSubscription({
        where: {
            pair: "ubtc:unusd",
            trader_address: "nibi14garegtvsx3zcku4esd30xd2pze7ck44ysxeg3",
        },
    }, __1.defaultPerpPosition);
}));
const testProxies = (fields) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield heartMonitor.proxies(fields);
    expect(resp).toHaveProperty("proxies");
    if (resp.proxies) {
        const { proxies } = resp;
        (0, __1.checkFields)([proxies], ["bybit"]);
    }
});
test("proxies", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testProxies(__1.defaultProxy);
}));
test("queryBatchHandler", () => __awaiter(void 0, void 0, void 0, function* () {
    var _r, _s, _t;
    // TODO: Make a partial type that includes all of these
    const resp = yield heartMonitor.GQLQueryGqlBatchHandler([
        (0, __1.communityPoolQueryString)({}, true, __1.defaultToken),
        (0, __1.featureFlagsQueryString)(true, __1.defaultFeatureFlags),
    ]);
    expect(resp).toHaveProperty("communityPool");
    expect(resp).toHaveProperty("featureFlags");
    if (((_s = (_r = resp.communityPool) === null || _r === void 0 ? void 0 : _r.length) !== null && _s !== void 0 ? _s : 0) > 0) {
        const [communityPool] = (_t = resp.communityPool) !== null && _t !== void 0 ? _t : [];
        (0, __1.checkFields)([communityPool], ["amount", "denom"]);
    }
    if (resp.featureFlags) {
        const { featureFlags } = resp;
        (0, __1.checkFields)([featureFlags], ["gov", "oracle", "perp", "spot", "staking", "wasm"]);
    }
}));
const testSpotLpPositions = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    var _u, _v, _w;
    const resp = yield heartMonitor.spotLpPositions(args, fields);
    expect(resp).toHaveProperty("spotLpPositions");
    if (((_v = (_u = resp.spotLpPositions) === null || _u === void 0 ? void 0 : _u.length) !== null && _v !== void 0 ? _v : 0) > 0) {
        const [spotLpPositions] = (_w = resp.spotLpPositions) !== null && _w !== void 0 ? _w : [];
        (0, __1.checkFields)([spotLpPositions], ["pool", "user", "pool_shares", "created_block"]);
    }
});
test("spotLpPositions", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testSpotLpPositions({}, __1.defaultSpotLpPosition);
}));
const testSpotPoolCreated = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    var _x, _y, _z;
    const resp = yield heartMonitor.spotPoolCreated(args, fields);
    expect(resp).toHaveProperty("spotPoolCreated");
    if (((_y = (_x = resp.spotPoolCreated) === null || _x === void 0 ? void 0 : _x.length) !== null && _y !== void 0 ? _y : 0) > 0) {
        const [spotPoolCreated] = (_z = resp.spotPoolCreated) !== null && _z !== void 0 ? _z : [];
        (0, __1.checkFields)([spotPoolCreated], ["user", "block", "pool", "pool_shares"]);
    }
});
test("spotPoolCreated", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testSpotPoolCreated({}, __1.defaultSpotPool);
}));
const testSpotPoolExited = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    var _0, _1, _2;
    const resp = yield heartMonitor.spotPoolExited(args, fields);
    expect(resp).toHaveProperty("spotPoolExited");
    if (((_1 = (_0 = resp.spotPoolExited) === null || _0 === void 0 ? void 0 : _0.length) !== null && _1 !== void 0 ? _1 : 0) > 0) {
        const [spotPoolExited] = (_2 = resp.spotPoolExited) !== null && _2 !== void 0 ? _2 : [];
        (0, __1.checkFields)([spotPoolExited], ["user", "block", "pool", "pool_shares"]);
    }
});
test("spotPoolExited", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testSpotPoolExited({}, __1.defaultSpotPool);
}));
const testSpotPoolJoined = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    var _3, _4, _5;
    const resp = yield heartMonitor.spotPoolJoined(args, fields);
    expect(resp).toHaveProperty("spotPoolJoined");
    if (((_4 = (_3 = resp.spotPoolJoined) === null || _3 === void 0 ? void 0 : _3.length) !== null && _4 !== void 0 ? _4 : 0) > 0) {
        const [spotPoolJoined] = (_5 = resp.spotPoolJoined) !== null && _5 !== void 0 ? _5 : [];
        (0, __1.checkFields)([spotPoolJoined], ["user", "block", "pool", "pool_shares"]);
    }
});
test("spotPoolJoined", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testSpotPoolJoined({}, __1.defaultSpotPool);
}));
const testSpotPools = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    var _6, _7, _8;
    const resp = yield heartMonitor.spotPools(args, fields);
    expect(resp).toHaveProperty("spotPools");
    if (((_7 = (_6 = resp.spotPools) === null || _6 === void 0 ? void 0 : _6.length) !== null && _7 !== void 0 ? _7 : 0) > 0) {
        const [spotPools] = (_8 = resp.spotPools) !== null && _8 !== void 0 ? _8 : [];
        (0, __1.checkFields)([spotPools], [
            "pool_id",
            "pool_type",
            "swap_fee",
            "exit_fee",
            "amplification",
            "tokens",
            "weights",
            "total_weight",
            "total_shares",
            "created_block",
        ]);
    }
});
test("spotPools", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testSpotPools({}, __1.defaultPool);
}));
const testSpotPoolSwap = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    var _9, _10, _11;
    const resp = yield heartMonitor.spotPoolSwap(args, fields);
    expect(resp).toHaveProperty("spotPoolSwap");
    if (((_10 = (_9 = resp.spotPoolSwap) === null || _9 === void 0 ? void 0 : _9.length) !== null && _10 !== void 0 ? _10 : 0) > 0) {
        const [spotPoolSwap] = (_11 = resp.spotPoolSwap) !== null && _11 !== void 0 ? _11 : [];
        (0, __1.checkFields)([spotPoolSwap], ["user", "block", "token_in", "token_out", "pool"]);
    }
});
test("spotPoolSwap", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testSpotPoolSwap({}, __1.defaultSpotPoolSwap);
}));
const testStats = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield heartMonitor.stats(args, fields);
    expect(resp).toHaveProperty("stats");
    if (resp.GQLStats) {
        const { GQLStats } = resp;
        (0, __1.checkFields)([GQLStats], [
            "totals",
            "fees",
            "perpOpenInterest",
            "tvl",
            "perpPnl",
            "users",
            "volume",
        ]);
    }
});
const testStaking = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield heartMonitor.staking(args, fields);
    expect(resp).toHaveProperty("staking");
    if (resp.staking) {
        const { staking } = resp;
        (0, __1.checkFields)([staking], ["delegations", "history", "redelegations", "unbondings", "validators"]);
    }
});
test.skip("staking", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testStaking({
        delegations: {
            limit: 10,
            order_desc: true,
        },
        history: {
            limit: 10,
            order_desc: true,
            where: {
                delegator: {
                    like: "nibi",
                },
            },
        },
        redelegations: {
            limit: 10,
        },
        unbondings: {
            limit: 10,
        },
        validators: {
            limit: 10,
            order_by: __1.GQLValidatorOrder.GQLTokens,
            order_desc: true,
        },
    }, {
        delegations: __1.defaultDelegations,
        redelegations: __1.defaultRedelegations,
        unbondings: __1.defaultUnbondings,
        validators: __1.defaultValidator,
        history: __1.defaultStakingHistoryItem,
    });
    yield testStaking({
        delegations: {},
        history: {},
        redelegations: {},
        unbondings: {},
        validators: {},
    }, {
        delegations: __1.defaultDelegations,
        redelegations: __1.defaultRedelegations,
        unbondings: __1.defaultUnbondings,
        validators: __1.defaultValidator,
        history: __1.defaultStakingHistoryItem,
    });
}));
test("stats", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testStats({
        totals: {
            limit: 1,
        },
        fees: {
            limit: 1,
        },
        perpOpenInterest: {
            limit: 1,
        },
        tvl: {
            limit: 1,
        },
        perpPnl: {
            limit: 1,
        },
        users: {
            limit: 1,
        },
        volume: {
            limit: 1,
        },
    }, {
        totals: __1.defaultTotals,
        fees: __1.defaultStatsFees,
        perpOpenInterest: __1.defaultPerpOpenInterest,
        tvl: __1.defaultTvl,
        perpPnl: __1.defaultPerpPnl,
        users: __1.defaultUsers,
        volume: __1.defaultVolume,
    });
    yield testStats({}, {
        totals: __1.defaultTotals,
        fees: __1.defaultStatsFees,
        perpOpenInterest: __1.defaultPerpOpenInterest,
        tvl: __1.defaultTvl,
        perpPnl: __1.defaultPerpPnl,
        users: __1.defaultUsers,
        volume: __1.defaultVolume,
    });
}));
const testWasm = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield heartMonitor.wasm(args, fields);
    expect(resp).toHaveProperty("wasm");
    if (resp.wasm) {
        const { wasm } = resp;
        (0, __1.checkFields)([wasm], ["userContracts"]);
    }
});
test("wasm", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testWasm({
        userContracts: {
            limit: 1,
        },
    }, {
        userContracts: __1.defaultUserContract,
    });
    yield testWasm({}, {
        userContracts: __1.defaultUserContract,
    });
}));
const testUser = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield heartMonitor.user(args, fields);
    expect(resp).toHaveProperty("user");
    const fieldsToCheck = ["address", "balances", "created_block", "is_blocked"];
    fieldsToCheck.forEach((field) => {
        expect(resp.user).toHaveProperty(field);
    });
});
test("user", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testUser({
        where: {
            address: "nibi14garegtvsx3zcku4esd30xd2pze7ck44ysxeg3",
        },
    }, Object.assign(Object.assign({}, __1.defaultUser), { is_blocked: true }));
}));
const testUsers = (args, fields) => __awaiter(void 0, void 0, void 0, function* () {
    var _12, _13, _14;
    const resp = yield heartMonitor.users(args, fields);
    expect(resp).toHaveProperty("users");
    if (((_13 = (_12 = resp.users) === null || _12 === void 0 ? void 0 : _12.length) !== null && _13 !== void 0 ? _13 : 0) > 0) {
        const [users] = (_14 = resp.users) !== null && _14 !== void 0 ? _14 : [];
        (0, __1.checkFields)([users], ["address", "balances", "created_block"]);
    }
});
test("users", () => __awaiter(void 0, void 0, void 0, function* () {
    yield testUsers({}, __1.defaultUser);
}));
describe("gql cleanResponse", () => {
    test("should return the response data if rawResp is ok and contains data", () => __awaiter(void 0, void 0, void 0, function* () {
        const rawResp = {
            ok: true,
            json: () => Promise.resolve({ data: "response data" }),
        };
        const result = yield (0, __1.cleanResponse)(rawResp);
        expect(result).toEqual("response data");
    }));
    test("should return the response JSON if rawResp is ok and does not contain data", () => __awaiter(void 0, void 0, void 0, function* () {
        const rawResp = {
            ok: true,
            json: () => Promise.resolve({ key: "value" }),
        };
        const result = yield (0, __1.cleanResponse)(rawResp);
        expect(result).toEqual({ key: "value" });
    }));
    test("should return an error if rawResp is not ok", () => __awaiter(void 0, void 0, void 0, function* () {
        const error = { error: "Error message" };
        const rawResp = {
            ok: false,
            json: () => Promise.resolve(error),
        };
        expect(yield (0, __1.cleanResponse)(rawResp)).toEqual(error);
    }));
    test("should throw an error if unable to parse JSON", () => __awaiter(void 0, void 0, void 0, function* () {
        const rawResp = {
            ok: true,
            json: () => Promise.reject(new Error("invalid json")),
        };
        expect(yield (0, __1.cleanResponse)(rawResp)).toEqual(undefined);
    }));
});
//# sourceMappingURL=heart-monitor.test.js.map