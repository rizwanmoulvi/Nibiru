export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<T extends {
    [key: string]: unknown;
}, K extends keyof T> = {
    [_ in K]?: never;
};
export type Incremental<T> = T | {
    [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
    ID: {
        input: string;
        output: string;
    };
    String: {
        input: string;
        output: string;
    };
    Boolean: {
        input: boolean;
        output: boolean;
    };
    Int: {
        input: number;
        output: number;
    };
    Float: {
        input: number;
        output: number;
    };
    Time: {
        input: string;
        output: string;
    };
};
export type GQLBlock = {
    readonly __typename?: 'Block';
    readonly block: Scalars['Int']['output'];
    readonly block_duration: Scalars['Float']['output'];
    readonly block_ts: Scalars['Int']['output'];
    readonly num_txs: Scalars['Int']['output'];
};
export type GQLBybitResponse = {
    readonly __typename?: 'BybitResponse';
    readonly ask1Price: Scalars['String']['output'];
    readonly ask1Size: Scalars['String']['output'];
    readonly bid1Price: Scalars['String']['output'];
    readonly bid1Size: Scalars['String']['output'];
    readonly highPrice24h: Scalars['String']['output'];
    readonly lastPrice: Scalars['String']['output'];
    readonly lowPrice24h: Scalars['String']['output'];
    readonly prevPrice24h: Scalars['String']['output'];
    readonly price24hPcnt: Scalars['String']['output'];
    readonly symbol: Scalars['String']['output'];
    readonly turnover24h: Scalars['String']['output'];
    readonly volume24h: Scalars['String']['output'];
};
export type GQLCommunityPoolFilter = {
    readonly denom?: InputMaybe<Scalars['String']['input']>;
};
export declare enum GQLCommunityPoolOrder {
    GQLDenom = "denom"
}
export type GQLContractEventsFilter = {
    readonly block?: InputMaybe<GQLIntFilter>;
    readonly contractAddress?: InputMaybe<GQLStringFilter>;
    readonly type?: InputMaybe<GQLStringFilter>;
};
export declare enum GQLContractEventsOrder {
    GQLContractAddress = "contract_address",
    GQLSequence = "sequence",
    GQLType = "type"
}
export type GQLDelegation = {
    readonly __typename?: 'Delegation';
    readonly amount: Scalars['Int']['output'];
    readonly delegator: GQLUser;
    readonly validator: GQLValidator;
};
export type GQLDelegationFilter = {
    readonly delegator_address?: InputMaybe<Scalars['String']['input']>;
    readonly validator_address?: InputMaybe<Scalars['String']['input']>;
};
export declare enum GQLDelegationOrder {
    GQLDelegatorAddress = "delegator_address",
    GQLValidatorAddress = "validator_address"
}
export type GQLDistributionCommission = {
    readonly __typename?: 'DistributionCommission';
    readonly commission?: Maybe<ReadonlyArray<GQLToken>>;
    readonly validator: GQLValidator;
};
export type GQLDistributionCommissionFilter = {
    readonly validator_address?: InputMaybe<Scalars['String']['input']>;
};
export declare enum GQLDistributionCommissionOrder {
    GQLValidatorAddress = "validator_address"
}
export type GQLEmployee = {
    readonly __typename?: 'Employee';
    readonly email: Scalars['String']['output'];
    readonly instagram: Scalars['String']['output'];
    readonly name: Scalars['String']['output'];
    readonly phone: Scalars['String']['output'];
    readonly telegram: Scalars['String']['output'];
    readonly twitter: Scalars['String']['output'];
};
export type GQLEmployeeFilter = {
    readonly email?: InputMaybe<Scalars['String']['input']>;
    readonly instagram?: InputMaybe<Scalars['String']['input']>;
    readonly name?: InputMaybe<Scalars['String']['input']>;
    readonly phone?: InputMaybe<Scalars['String']['input']>;
    readonly telegram?: InputMaybe<Scalars['String']['input']>;
    readonly twitter?: InputMaybe<Scalars['String']['input']>;
};
export type GQLEvent = {
    readonly __typename?: 'Event';
    readonly attributes: ReadonlyArray<GQLEventAttribute>;
    readonly block: GQLBlock;
    readonly contractAddress?: Maybe<Scalars['String']['output']>;
    readonly eventSeqNo: Scalars['Int']['output'];
    readonly txSeqNo: Scalars['Int']['output'];
    readonly type: Scalars['String']['output'];
};
export type GQLEventAttribute = {
    readonly __typename?: 'EventAttribute';
    readonly key: Scalars['String']['output'];
    readonly value: Scalars['String']['output'];
};
export type GQLFeatureFlags = {
    readonly __typename?: 'FeatureFlags';
    readonly gov: Scalars['Boolean']['output'];
    readonly oracle: Scalars['Boolean']['output'];
    readonly perp: Scalars['Boolean']['output'];
    readonly spot: Scalars['Boolean']['output'];
    readonly staking: Scalars['Boolean']['output'];
    readonly wasm: Scalars['Boolean']['output'];
};
export type GQLFloatFilter = {
    readonly eq?: InputMaybe<Scalars['Float']['input']>;
    readonly gt?: InputMaybe<Scalars['Float']['input']>;
    readonly gte?: InputMaybe<Scalars['Float']['input']>;
    readonly lt?: InputMaybe<Scalars['Float']['input']>;
    readonly lte?: InputMaybe<Scalars['Float']['input']>;
};
export type GQLGovDeposit = {
    readonly __typename?: 'GovDeposit';
    readonly amount: ReadonlyArray<GQLToken>;
    readonly block: GQLBlock;
    readonly proposal: GQLGovProposal;
    readonly sender: GQLUser;
};
export type GQLGovDepositsFilter = {
    readonly block?: InputMaybe<GQLIntFilter>;
    readonly proposalId?: InputMaybe<GQLIntFilter>;
    readonly senderEq?: InputMaybe<Scalars['String']['input']>;
};
export declare enum GQLGovDepositsOrder {
    GQLBlock = "block",
    GQLProposalId = "proposal_id",
    GQLSender = "sender"
}
export type GQLGovProposal = {
    readonly __typename?: 'GovProposal';
    readonly depositEndTime: Scalars['Time']['output'];
    readonly finalTallyResultAbstain: Scalars['Int']['output'];
    readonly finalTallyResultNo: Scalars['Int']['output'];
    readonly finalTallyResultNoWithVeto: Scalars['Int']['output'];
    readonly finalTallyResultYes: Scalars['Int']['output'];
    readonly id: Scalars['Int']['output'];
    readonly metadata: Scalars['String']['output'];
    readonly proposer: GQLUser;
    readonly status: Scalars['String']['output'];
    readonly submitTime: Scalars['Time']['output'];
    readonly summary: Scalars['String']['output'];
    readonly title: Scalars['String']['output'];
    readonly totalDeposit: ReadonlyArray<GQLToken>;
    readonly votingEndTime?: Maybe<Scalars['Time']['output']>;
    readonly votingStartTime?: Maybe<Scalars['Time']['output']>;
};
export type GQLGovProposalsFilter = {
    readonly depositEndTime?: InputMaybe<GQLTimeFilter>;
    readonly finalTallyResultAbstain?: InputMaybe<GQLIntFilter>;
    readonly finalTallyResultNo?: InputMaybe<GQLIntFilter>;
    readonly finalTallyResultNoWithVeto?: InputMaybe<GQLIntFilter>;
    readonly finalTallyResultYes?: InputMaybe<GQLIntFilter>;
    readonly id?: InputMaybe<GQLIntFilter>;
    readonly proposerEq?: InputMaybe<Scalars['String']['input']>;
    readonly submitTime?: InputMaybe<GQLTimeFilter>;
    readonly summary?: InputMaybe<GQLStringFilter>;
    readonly title?: InputMaybe<GQLStringFilter>;
    readonly votingEndTime?: InputMaybe<GQLTimeFilter>;
    readonly votingStartTime?: InputMaybe<GQLTimeFilter>;
};
export declare enum GQLGovProposalsOrder {
    GQLDepositEndTime = "deposit_end_time",
    GQLFinalTallyResultAbstain = "final_tally_result_abstain",
    GQLFinalTallyResultNo = "final_tally_result_no",
    GQLFinalTallyResultNoWithVeto = "final_tally_result_no_with_veto",
    GQLFinalTallyResultYes = "final_tally_result_yes",
    GQLId = "id",
    GQLProposer = "proposer",
    GQLStatus = "status",
    GQLSubmitTime = "submit_time",
    GQLSummary = "summary",
    GQLTitle = "title",
    GQLVotingEndTime = "voting_end_time",
    GQLVotingStartTime = "voting_start_time"
}
export type GQLGovVote = {
    readonly __typename?: 'GovVote';
    readonly block: GQLBlock;
    readonly option: Scalars['String']['output'];
    readonly proposal: GQLGovProposal;
    readonly sender: GQLUser;
};
export type GQLGovVotesFilter = {
    readonly block?: InputMaybe<GQLIntFilter>;
    readonly optionEq?: InputMaybe<Scalars['String']['input']>;
    readonly proposalId?: InputMaybe<GQLIntFilter>;
    readonly senderEq?: InputMaybe<Scalars['String']['input']>;
};
export declare enum GQLGovVotesOrder {
    GQLBlock = "block",
    GQLOption = "option",
    GQLProposalId = "proposal_id",
    GQLSender = "sender"
}
export type GQLGovernance = {
    readonly __typename?: 'Governance';
    readonly govDeposits: ReadonlyArray<GQLGovDeposit>;
    readonly govProposals: ReadonlyArray<GQLGovProposal>;
    readonly govVotes: ReadonlyArray<GQLGovVote>;
};
export type GQLGovernanceGqlGovDepositsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order?: InputMaybe<GQLGovDepositsOrder>;
    orderDesc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLGovDepositsFilter>;
};
export type GQLGovernanceGqlGovProposalsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order?: InputMaybe<GQLGovProposalsOrder>;
    orderDesc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLGovProposalsFilter>;
};
export type GQLGovernanceGqlGovVotesArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order?: InputMaybe<GQLGovVotesOrder>;
    orderDesc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLGovVotesFilter>;
};
export type GQLIbc = {
    readonly __typename?: 'IBC';
    readonly ibcChannels: GQLIbcChannelsResponse;
    readonly ibcTransfers: ReadonlyArray<GQLIbcTransfer>;
};
export type GQLIbcgqlIbcTransfersArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLIbcTranferOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLIbcTranferFilter>;
};
export type GQLIbcChannel = {
    readonly __typename?: 'IBCChannel';
    readonly chain_id: Scalars['String']['output'];
    readonly chain_logo: Scalars['String']['output'];
    readonly chain_name: Scalars['String']['output'];
    readonly channel_id: Scalars['String']['output'];
    readonly counterparty_channel_id: Scalars['String']['output'];
    readonly revision_height: Scalars['Int']['output'];
};
export type GQLIbcChannelsResponse = {
    readonly __typename?: 'IBCChannelsResponse';
    readonly channels: ReadonlyArray<GQLIbcChannel>;
    readonly revision_height: Scalars['Int']['output'];
};
export type GQLIbcTranferFilter = {
    readonly receiver?: InputMaybe<Scalars['String']['input']>;
    readonly sender?: InputMaybe<Scalars['String']['input']>;
};
export declare enum GQLIbcTranferOrder {
    GQLBlock = "block",
    GQLReceiver = "receiver",
    GQLSender = "sender"
}
export type GQLIbcTransfer = {
    readonly __typename?: 'IBCTransfer';
    readonly amount: Scalars['Float']['output'];
    readonly block: GQLBlock;
    readonly denom: Scalars['String']['output'];
    readonly memo: Scalars['String']['output'];
    readonly receiver: Scalars['String']['output'];
    readonly sender: Scalars['String']['output'];
};
export type GQLInflation = {
    readonly __typename?: 'Inflation';
    readonly distributions: ReadonlyArray<GQLInflationDistribution>;
    readonly inflations: ReadonlyArray<GQLInflationInfo>;
    readonly rewards?: Maybe<GQLInflationRewards>;
};
export type GQLInflationGqlDistributionsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLInflationDistributionOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLInflationDistributionFilter>;
};
export type GQLInflationGqlInflationsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLInflationInfoOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLInflationInfoFilter>;
};
export type GQLInflationDistribution = {
    readonly __typename?: 'InflationDistribution';
    readonly block: GQLBlock;
    readonly communityPool: Scalars['Float']['output'];
    readonly eventSeqNo: Scalars['Int']['output'];
    readonly stakingRewards: Scalars['Float']['output'];
    readonly strategicReserve: Scalars['Float']['output'];
    readonly txSeqNo: Scalars['Int']['output'];
};
export type GQLInflationDistributionFilter = {
    readonly block?: InputMaybe<GQLIntFilter>;
    readonly blockTs?: InputMaybe<GQLTimeFilter>;
};
export declare enum GQLInflationDistributionOrder {
    GQLSequence = "sequence"
}
export type GQLInflationInfo = {
    readonly __typename?: 'InflationInfo';
    readonly amount: Scalars['Float']['output'];
    readonly block: GQLBlock;
    readonly epochNumber: Scalars['Int']['output'];
    readonly epochProvisions: Scalars['Float']['output'];
};
export type GQLInflationInfoFilter = {
    readonly block?: InputMaybe<GQLIntFilter>;
    readonly blockTs?: InputMaybe<GQLTimeFilter>;
    readonly epochNumber?: InputMaybe<GQLIntFilter>;
};
export declare enum GQLInflationInfoOrder {
    GQLBlock = "block",
    GQLEpochNumber = "epoch_number"
}
export type GQLInflationRewards = {
    readonly __typename?: 'InflationRewards';
    readonly annualReward: Scalars['Int']['output'];
    readonly totalStaked: Scalars['Int']['output'];
};
export type GQLIntFilter = {
    readonly eq?: InputMaybe<Scalars['Int']['input']>;
    readonly gt?: InputMaybe<Scalars['Int']['input']>;
    readonly gte?: InputMaybe<Scalars['Int']['input']>;
    readonly lt?: InputMaybe<Scalars['Int']['input']>;
    readonly lte?: InputMaybe<Scalars['Int']['input']>;
};
export type GQLInternal = {
    readonly __typename?: 'Internal';
    readonly employee?: Maybe<GQLEmployee>;
};
export type GQLInternalGqlEmployeeArgs = {
    where: GQLEmployeeFilter;
};
export type GQLIntervalPeriodFilter = {
    readonly periodEq?: InputMaybe<Scalars['String']['input']>;
    readonly periodGt?: InputMaybe<Scalars['String']['input']>;
    readonly periodGte?: InputMaybe<Scalars['String']['input']>;
    readonly periodLt?: InputMaybe<Scalars['String']['input']>;
    readonly periodLte?: InputMaybe<Scalars['String']['input']>;
    readonly periodStartTsEq?: InputMaybe<Scalars['Time']['input']>;
    readonly periodStartTsGt?: InputMaybe<Scalars['Time']['input']>;
    readonly periodStartTsGte?: InputMaybe<Scalars['Time']['input']>;
    readonly periodStartTsLt?: InputMaybe<Scalars['Time']['input']>;
    readonly periodStartTsLte?: InputMaybe<Scalars['Time']['input']>;
};
export type GQLMarkPriceCandle = {
    readonly __typename?: 'MarkPriceCandle';
    readonly close: Scalars['Float']['output'];
    readonly high: Scalars['Float']['output'];
    readonly indexPriceTwapClose: Scalars['Float']['output'];
    readonly low: Scalars['Float']['output'];
    readonly open: Scalars['Float']['output'];
    readonly pair: Scalars['String']['output'];
    /** @deprecated Use periodInterval instead */
    readonly period: Scalars['Int']['output'];
    readonly periodInterval: Scalars['String']['output'];
    readonly periodStartTs: Scalars['Time']['output'];
    readonly volume: Scalars['Float']['output'];
    readonly volumeNotional: Scalars['Float']['output'];
};
export type GQLMarkPriceCandlesFilter = {
    readonly intervalPeriodEq?: InputMaybe<Scalars['String']['input']>;
    readonly intervalPeriodGt?: InputMaybe<Scalars['String']['input']>;
    readonly intervalPeriodGte?: InputMaybe<Scalars['String']['input']>;
    readonly intervalPeriodLt?: InputMaybe<Scalars['String']['input']>;
    readonly intervalPeriodLte?: InputMaybe<Scalars['String']['input']>;
    readonly pairEq?: InputMaybe<Scalars['String']['input']>;
    readonly periodEq?: InputMaybe<Scalars['Int']['input']>;
    readonly periodGt?: InputMaybe<Scalars['Int']['input']>;
    readonly periodGte?: InputMaybe<Scalars['Int']['input']>;
    readonly periodLt?: InputMaybe<Scalars['Int']['input']>;
    readonly periodLte?: InputMaybe<Scalars['Int']['input']>;
    readonly periodStartTsEq?: InputMaybe<Scalars['Time']['input']>;
    readonly periodStartTsGt?: InputMaybe<Scalars['Time']['input']>;
    readonly periodStartTsGte?: InputMaybe<Scalars['Time']['input']>;
    readonly periodStartTsLt?: InputMaybe<Scalars['Time']['input']>;
    readonly periodStartTsLte?: InputMaybe<Scalars['Time']['input']>;
};
export declare enum GQLMarkPriceCandlesOrder {
    GQLPeriod = "period",
    GQLPeriodStartTs = "period_start_ts"
}
export type GQLOracle = {
    readonly __typename?: 'Oracle';
    readonly oraclePrices: ReadonlyArray<GQLOraclePrice>;
    readonly oracles: ReadonlyArray<GQLOracleEntry>;
};
export type GQLOracleGqlOraclePricesArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLOraclePricesOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLOraclePricesFilter>;
};
export type GQLOracleGqlOraclesArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLOraclesOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLOraclesFilter>;
};
export type GQLOracleEntry = {
    readonly __typename?: 'OracleEntry';
    readonly numVotes: Scalars['Int']['output'];
    readonly validator: GQLValidator;
};
export type GQLOraclePrice = {
    readonly __typename?: 'OraclePrice';
    readonly block: GQLBlock;
    /** @deprecated Not applicable for oracle prices */
    readonly eventSeqNo: Scalars['Int']['output'];
    readonly pair: Scalars['String']['output'];
    readonly price: Scalars['Float']['output'];
    /** @deprecated Not applicable for oracle prices */
    readonly txSeqNo: Scalars['Int']['output'];
};
export type GQLOraclePricesFilter = {
    readonly block?: InputMaybe<GQLIntFilter>;
    readonly pair?: InputMaybe<GQLStringFilter>;
};
export declare enum GQLOraclePricesOrder {
    GQLPair = "pair",
    GQLPrice = "price",
    GQLSequence = "sequence"
}
export type GQLOraclesFilter = {
    readonly numVotes?: InputMaybe<GQLIntFilter>;
    readonly validatorAddressEq?: InputMaybe<Scalars['String']['input']>;
};
export declare enum GQLOraclesOrder {
    GQLNumVotes = "num_votes",
    GQLValidatorAddress = "validator_address"
}
export type GQLPeriodFilter = {
    readonly intervalPeriodEq?: InputMaybe<Scalars['String']['input']>;
    readonly intervalPeriodGt?: InputMaybe<Scalars['String']['input']>;
    readonly intervalPeriodGte?: InputMaybe<Scalars['String']['input']>;
    readonly intervalPeriodLt?: InputMaybe<Scalars['String']['input']>;
    readonly intervalPeriodLte?: InputMaybe<Scalars['String']['input']>;
    readonly periodEq?: InputMaybe<Scalars['Int']['input']>;
    readonly periodGt?: InputMaybe<Scalars['Int']['input']>;
    readonly periodGte?: InputMaybe<Scalars['Int']['input']>;
    readonly periodLt?: InputMaybe<Scalars['Int']['input']>;
    readonly periodLte?: InputMaybe<Scalars['Int']['input']>;
    readonly periodStartTsEq?: InputMaybe<Scalars['Time']['input']>;
    readonly periodStartTsGt?: InputMaybe<Scalars['Time']['input']>;
    readonly periodStartTsGte?: InputMaybe<Scalars['Time']['input']>;
    readonly periodStartTsLt?: InputMaybe<Scalars['Time']['input']>;
    readonly periodStartTsLte?: InputMaybe<Scalars['Time']['input']>;
};
export type GQLPerp = {
    readonly __typename?: 'Perp';
    readonly leaderboard: ReadonlyArray<GQLPerpLeaderboard>;
    readonly market?: Maybe<GQLPerpMarket>;
    readonly markets: ReadonlyArray<GQLPerpMarket>;
    readonly position?: Maybe<GQLPerpPosition>;
    readonly positionChanges: ReadonlyArray<GQLPerpPositionChange>;
    readonly positions: ReadonlyArray<GQLPerpPosition>;
};
export type GQLPerpGqlLeaderboardArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLPerpLeaderboardOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLPerpLeaderboardFilter>;
};
export type GQLPerpGqlMarketArgs = {
    where: GQLPerpMarketFilter;
};
export type GQLPerpGqlMarketsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLPerpMarketOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLPerpMarketsFilter>;
};
export type GQLPerpGqlPositionArgs = {
    where: GQLPerpPositionFilter;
};
export type GQLPerpGqlPositionChangesArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLPerpPositionChangeOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where: GQLPerpPositionChangeFilter;
};
export type GQLPerpGqlPositionsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLPerpPositionOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLPerpPositionsFilter>;
};
export type GQLPerpLeaderboard = {
    readonly __typename?: 'PerpLeaderboard';
    readonly avg_pct_pnl: Scalars['Float']['output'];
    readonly avg_pct_pnl_rank: Scalars['Int']['output'];
    readonly input_margin: Scalars['Float']['output'];
    readonly raw_pnl: Scalars['Float']['output'];
    readonly raw_pnl_with_unrealized: Scalars['Float']['output'];
    readonly trader_address: Scalars['String']['output'];
};
export type GQLPerpLeaderboardFilter = {
    readonly trader_address?: InputMaybe<Scalars['String']['input']>;
};
export declare enum GQLPerpLeaderboardOrder {
    GQLAvgPctPnl = "avg_pct_pnl",
    GQLAvgPctPnlRank = "avg_pct_pnl_rank",
    GQLRawPnl = "raw_pnl",
    GQLRawPnlWithUnrealized = "raw_pnl_with_unrealized",
    GQLTraderAddress = "trader_address"
}
export type GQLPerpMarket = {
    readonly __typename?: 'PerpMarket';
    readonly base_reserve: Scalars['Float']['output'];
    readonly ecosystem_fund_fee_ratio: Scalars['Float']['output'];
    readonly enabled: Scalars['Boolean']['output'];
    readonly exchange_fee_ratio: Scalars['Float']['output'];
    readonly funding_rate_epoch_id: Scalars['String']['output'];
    readonly index_price_twap: Scalars['Float']['output'];
    readonly is_deleted: Scalars['Boolean']['output'];
    readonly latest_cumulative_premium_fraction: Scalars['Float']['output'];
    readonly liquidation_fee_ratio: Scalars['Float']['output'];
    readonly maintenance_margin_ratio: Scalars['Float']['output'];
    readonly mark_price: Scalars['Float']['output'];
    readonly mark_price_twap: Scalars['Float']['output'];
    readonly max_funding_rate?: Maybe<Scalars['Float']['output']>;
    readonly max_leverage: Scalars['Float']['output'];
    readonly pair: Scalars['String']['output'];
    readonly partial_liquidation_ratio: Scalars['Float']['output'];
    readonly prepaid_bad_debt: GQLToken;
    readonly price_multiplier: Scalars['Float']['output'];
    readonly quote_reserve: Scalars['Float']['output'];
    readonly sqrt_depth: Scalars['Float']['output'];
    readonly total_long: Scalars['Float']['output'];
    readonly total_short: Scalars['Float']['output'];
    readonly twap_lookback_window: Scalars['String']['output'];
};
export type GQLPerpMarketFilter = {
    readonly pair: Scalars['String']['input'];
};
export declare enum GQLPerpMarketOrder {
    GQLPair = "pair"
}
export type GQLPerpMarketsFilter = {
    readonly is_deleted?: InputMaybe<Scalars['Boolean']['input']>;
    readonly pair?: InputMaybe<Scalars['String']['input']>;
};
export type GQLPerpPosition = {
    readonly __typename?: 'PerpPosition';
    readonly bad_debt: Scalars['Float']['output'];
    readonly last_updated_block: GQLBlock;
    readonly latest_cumulative_premium_fraction: Scalars['Float']['output'];
    readonly liquidation_price: Scalars['Float']['output'];
    readonly margin: Scalars['Float']['output'];
    readonly margin_ratio: Scalars['Float']['output'];
    readonly open_notional: Scalars['Float']['output'];
    readonly pair: Scalars['String']['output'];
    readonly position_notional: Scalars['Float']['output'];
    readonly size: Scalars['Float']['output'];
    readonly trader_address: Scalars['String']['output'];
    readonly unrealized_funding_payment: Scalars['Float']['output'];
    readonly unrealized_pnl: Scalars['Float']['output'];
};
export type GQLPerpPositionChange = {
    readonly __typename?: 'PerpPositionChange';
    readonly badDebt?: Maybe<GQLToken>;
    readonly block: GQLBlock;
    readonly changeReason: Scalars['String']['output'];
    readonly eventSeqNo: Scalars['Int']['output'];
    readonly exchangedNotional: Scalars['Float']['output'];
    readonly exchangedSize: Scalars['Float']['output'];
    readonly fundingPayment?: Maybe<Scalars['Float']['output']>;
    readonly latestCumulativePremiumFraction?: Maybe<Scalars['Float']['output']>;
    readonly margin: Scalars['Float']['output'];
    readonly marginToUser?: Maybe<Scalars['Int']['output']>;
    readonly openNotional: Scalars['Float']['output'];
    readonly pair: Scalars['String']['output'];
    readonly positionNotional: Scalars['Float']['output'];
    readonly realizedPnl?: Maybe<Scalars['Float']['output']>;
    readonly size: Scalars['Float']['output'];
    readonly traderAddress: Scalars['String']['output'];
    readonly transactionFee?: Maybe<GQLToken>;
    readonly txSeqNo: Scalars['Int']['output'];
};
export type GQLPerpPositionChangeFilter = {
    readonly block?: InputMaybe<GQLIntFilter>;
    readonly blockTs?: InputMaybe<GQLTimeFilter>;
    readonly pair?: InputMaybe<GQLStringFilter>;
    readonly traderAddressEq: Scalars['String']['input'];
};
export declare enum GQLPerpPositionChangeOrder {
    GQLExchangedNotional = "exchanged_notional",
    GQLExchangedSize = "exchanged_size",
    GQLMargin = "margin",
    GQLOpenNotional = "open_notional",
    GQLPair = "pair",
    GQLPositionNotional = "position_notional",
    GQLSequence = "sequence",
    GQLSize = "size"
}
export type GQLPerpPositionFilter = {
    readonly pair: Scalars['String']['input'];
    readonly trader_address: Scalars['String']['input'];
};
export declare enum GQLPerpPositionOrder {
    GQLCreatedBlock = "created_block",
    GQLPair = "pair",
    GQLTraderAddress = "trader_address"
}
export type GQLPerpPositionsFilter = {
    readonly include_closed?: InputMaybe<Scalars['Boolean']['input']>;
    readonly pair?: InputMaybe<Scalars['String']['input']>;
    readonly trader_address?: InputMaybe<Scalars['String']['input']>;
};
export type GQLProxies = {
    readonly __typename?: 'Proxies';
    readonly bybit: GQLBybitResponse;
};
export type GQLQuery = {
    readonly __typename?: 'Query';
    readonly communityPool: ReadonlyArray<GQLToken>;
    /** @deprecated Moved to staking sub schema */
    readonly delegations: ReadonlyArray<GQLDelegation>;
    readonly distributionCommissions: ReadonlyArray<GQLDistributionCommission>;
    readonly featureFlags: GQLFeatureFlags;
    readonly governance: GQLGovernance;
    readonly ibc: GQLIbc;
    readonly inflation: GQLInflation;
    readonly internal: GQLInternal;
    /** @deprecated Will be removed next releases */
    readonly markPriceCandles: ReadonlyArray<GQLMarkPriceCandle>;
    readonly oracle: GQLOracle;
    /** @deprecated Will be removed next releases */
    readonly perp: GQLPerp;
    readonly proxies: GQLProxies;
    /** @deprecated Moved to staking sub schema */
    readonly redelegations: ReadonlyArray<GQLRedelegation>;
    /** @deprecated Will be removed next releases */
    readonly spotLpPositions: ReadonlyArray<GQLSpotLpPosition>;
    /** @deprecated Will be removed next releases */
    readonly spotPoolCreated: ReadonlyArray<GQLSpotPoolCreated>;
    /** @deprecated Will be removed next releases */
    readonly spotPoolExited: ReadonlyArray<GQLSpotPoolExited>;
    /** @deprecated Will be removed next releases */
    readonly spotPoolJoined: ReadonlyArray<GQLSpotPoolJoined>;
    /** @deprecated Will be removed next releases */
    readonly spotPoolSwap: ReadonlyArray<GQLSpotPoolSwap>;
    /** @deprecated Will be removed next releases */
    readonly spotPools: ReadonlyArray<GQLSpotPool>;
    readonly staking: GQLStaking;
    readonly stats: GQLStats;
    /** @deprecated Moved to staking sub schema */
    readonly unbondings: ReadonlyArray<GQLUnbonding>;
    readonly user?: Maybe<GQLUser>;
    readonly users: ReadonlyArray<GQLUser>;
    /** @deprecated Moved to staking sub schema */
    readonly validators: ReadonlyArray<GQLValidator>;
    readonly wasm: GQLWasm;
};
export type GQLQueryGqlCommunityPoolArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLCommunityPoolOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLCommunityPoolFilter>;
};
export type GQLQueryGqlDelegationsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLDelegationOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLDelegationFilter>;
};
export type GQLQueryGqlDistributionCommissionsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLDistributionCommissionOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLDistributionCommissionFilter>;
};
export type GQLQueryGqlMarkPriceCandlesArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLMarkPriceCandlesOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLMarkPriceCandlesFilter>;
};
export type GQLQueryGqlRedelegationsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLRedelegationOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLRedelegationFilter>;
};
export type GQLQueryGqlSpotLpPositionsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLSpotLpPositionOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLSpotLpPositionFilter>;
};
export type GQLQueryGqlSpotPoolCreatedArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLSpotPoolCreatedOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLSpotPoolCreatedFilter>;
};
export type GQLQueryGqlSpotPoolExitedArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLSpotPoolExitedOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLSpotPoolExitedFilter>;
};
export type GQLQueryGqlSpotPoolJoinedArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLSpotPoolJoinedOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLSpotPoolJoinedFilter>;
};
export type GQLQueryGqlSpotPoolSwapArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLSpotPoolSwapOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLSpotPoolSwapFilter>;
};
export type GQLQueryGqlSpotPoolsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLSpotPoolOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLSpotPoolFilter>;
};
export type GQLQueryGqlUnbondingsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLUnbondingOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLUnbondingFilter>;
};
export type GQLQueryGqlUserArgs = {
    where: GQLUserFilter;
};
export type GQLQueryGqlUsersArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLUserOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLUsersFilter>;
};
export type GQLQueryGqlValidatorsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLValidatorOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLValidatorFilter>;
};
export type GQLRedelegation = {
    readonly __typename?: 'Redelegation';
    readonly amount: Scalars['Int']['output'];
    readonly completion_time: Scalars['String']['output'];
    readonly creation_block: GQLBlock;
    readonly delegator: GQLUser;
    readonly destination_validator: GQLValidator;
    readonly source_validator: GQLValidator;
};
export type GQLRedelegationFilter = {
    readonly delegator_address?: InputMaybe<Scalars['String']['input']>;
    readonly destination_validator_address?: InputMaybe<Scalars['String']['input']>;
    readonly source_validator_address?: InputMaybe<Scalars['String']['input']>;
};
export declare enum GQLRedelegationOrder {
    GQLCompletionTime = "completion_time",
    GQLCreationHeight = "creation_height",
    GQLDelegatorAddress = "delegator_address",
    GQLDestinationValidatorAddress = "destination_validator_address",
    GQLSourceValidatorAddress = "source_validator_address"
}
export type GQLSpotLpPosition = {
    readonly __typename?: 'SpotLpPosition';
    readonly created_block: GQLBlock;
    readonly pool: GQLSpotPool;
    readonly pool_shares: GQLToken;
    readonly user: GQLUser;
};
export type GQLSpotLpPositionFilter = {
    readonly pool_id?: InputMaybe<Scalars['Int']['input']>;
    readonly user_address?: InputMaybe<Scalars['String']['input']>;
};
export declare enum GQLSpotLpPositionOrder {
    GQLPoolId = "pool_id",
    GQLUserAddress = "user_address"
}
export type GQLSpotPool = {
    readonly __typename?: 'SpotPool';
    readonly amplification: Scalars['Float']['output'];
    readonly created_block: GQLBlock;
    readonly exit_fee: Scalars['Float']['output'];
    readonly pool_id: Scalars['Int']['output'];
    readonly pool_type: Scalars['String']['output'];
    readonly swap_fee: Scalars['Float']['output'];
    readonly tokens: ReadonlyArray<GQLToken>;
    readonly total_shares: GQLToken;
    readonly total_weight: Scalars['Float']['output'];
    readonly weights: ReadonlyArray<GQLToken>;
};
export type GQLSpotPoolCreated = {
    readonly __typename?: 'SpotPoolCreated';
    readonly block: GQLBlock;
    readonly pool: GQLSpotPool;
    readonly pool_shares: GQLToken;
    readonly user: GQLUser;
};
export type GQLSpotPoolCreatedFilter = {
    readonly pool_id?: InputMaybe<Scalars['Int']['input']>;
    readonly user_address?: InputMaybe<Scalars['String']['input']>;
};
export declare enum GQLSpotPoolCreatedOrder {
    GQLPoolId = "pool_id",
    GQLUserAddress = "user_address"
}
export type GQLSpotPoolExited = {
    readonly __typename?: 'SpotPoolExited';
    readonly block: GQLBlock;
    readonly pool: GQLSpotPool;
    readonly pool_shares: GQLToken;
    readonly user: GQLUser;
};
export type GQLSpotPoolExitedFilter = {
    readonly pool_id?: InputMaybe<Scalars['Int']['input']>;
    readonly user_address?: InputMaybe<Scalars['String']['input']>;
};
export declare enum GQLSpotPoolExitedOrder {
    GQLPoolId = "pool_id",
    GQLUserAddress = "user_address"
}
export type GQLSpotPoolFilter = {
    readonly pool_id?: InputMaybe<Scalars['Int']['input']>;
};
export type GQLSpotPoolJoined = {
    readonly __typename?: 'SpotPoolJoined';
    readonly block: GQLBlock;
    readonly pool: GQLSpotPool;
    readonly pool_shares: GQLToken;
    readonly user: GQLUser;
};
export type GQLSpotPoolJoinedFilter = {
    readonly pool_id?: InputMaybe<Scalars['Int']['input']>;
    readonly user_address?: InputMaybe<Scalars['String']['input']>;
};
export declare enum GQLSpotPoolJoinedOrder {
    GQLPoolId = "pool_id",
    GQLUserAddress = "user_address"
}
export declare enum GQLSpotPoolOrder {
    GQLPoolId = "pool_id"
}
export type GQLSpotPoolSwap = {
    readonly __typename?: 'SpotPoolSwap';
    readonly block: GQLBlock;
    readonly pool: GQLSpotPool;
    readonly token_in: GQLToken;
    readonly token_out: GQLToken;
    readonly user: GQLUser;
};
export type GQLSpotPoolSwapFilter = {
    readonly block_eq?: InputMaybe<Scalars['Int']['input']>;
    readonly block_gte?: InputMaybe<Scalars['Int']['input']>;
    readonly block_lte?: InputMaybe<Scalars['Int']['input']>;
    readonly pool_id?: InputMaybe<Scalars['Int']['input']>;
    readonly user_address?: InputMaybe<Scalars['String']['input']>;
};
export declare enum GQLSpotPoolSwapOrder {
    GQLBlock = "block",
    GQLPoolId = "pool_id",
    GQLUserAddress = "user_address"
}
export type GQLStaking = {
    readonly __typename?: 'Staking';
    readonly delegations: ReadonlyArray<GQLDelegation>;
    readonly history: ReadonlyArray<GQLStakingHistoryItem>;
    readonly redelegations: ReadonlyArray<GQLRedelegation>;
    readonly unbondings: ReadonlyArray<GQLUnbonding>;
    readonly validators: ReadonlyArray<GQLValidator>;
};
export type GQLStakingGqlDelegationsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLDelegationOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLDelegationFilter>;
};
export type GQLStakingGqlHistoryArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLStakingHistoryOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLStakingHistoryFilter>;
};
export type GQLStakingGqlRedelegationsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLRedelegationOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLRedelegationFilter>;
};
export type GQLStakingGqlUnbondingsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLUnbondingOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLUnbondingFilter>;
};
export type GQLStakingGqlValidatorsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order_by?: InputMaybe<GQLValidatorOrder>;
    order_desc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLValidatorFilter>;
};
export declare enum GQLStakingActionType {
    GQLCancel = "cancel",
    GQLDelegate = "delegate",
    GQLRedelegate = "redelegate",
    GQLRedelegateCompleted = "redelegate_completed",
    GQLUnbond = "unbond",
    GQLUnbondCompleted = "unbond_completed",
    GQLWithdraw = "withdraw"
}
export type GQLStakingHistoryFilter = {
    readonly actions?: InputMaybe<ReadonlyArray<GQLStakingActionType>>;
    readonly amount?: InputMaybe<GQLIntFilter>;
    readonly block?: InputMaybe<GQLIntFilter>;
    readonly completionTime?: InputMaybe<GQLTimeFilter>;
    readonly delegator?: InputMaybe<GQLStringFilter>;
    readonly validator?: InputMaybe<GQLStringFilter>;
};
export type GQLStakingHistoryItem = {
    readonly __typename?: 'StakingHistoryItem';
    readonly action: GQLStakingActionType;
    readonly amount: Scalars['Int']['output'];
    readonly block: GQLBlock;
    readonly completion_time?: Maybe<Scalars['Time']['output']>;
    readonly delegator: GQLUser;
    readonly destination_validator?: Maybe<GQLValidator>;
    readonly validator: GQLValidator;
};
export declare enum GQLStakingHistoryOrder {
    GQLAction = "action",
    GQLAmount = "amount",
    GQLDelegator = "delegator",
    GQLSequence = "sequence",
    GQLValidator = "validator"
}
export type GQLStats = {
    readonly __typename?: 'Stats';
    readonly currentMetrics: GQLStatsCurrentMetrics;
    readonly fees: ReadonlyArray<GQLStatsFees>;
    readonly inflation: ReadonlyArray<GQLStatsInflation>;
    readonly perpOpenInterest: ReadonlyArray<GQLStatsPerpOpenInterest>;
    readonly perpPnl: ReadonlyArray<GQLStatsPerpPnl>;
    readonly totals: ReadonlyArray<GQLStatsTotals>;
    readonly tvl: ReadonlyArray<GQLStatsTvl>;
    readonly users: ReadonlyArray<GQLStatsUsers>;
    readonly volume: ReadonlyArray<GQLStatsVolume>;
};
export type GQLStatsGqlFeesArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order?: InputMaybe<GQLStatsFeesOrder>;
    orderDesc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLPeriodFilter>;
};
export type GQLStatsGqlInflationArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order?: InputMaybe<GQLStatsInflationOrder>;
    orderDesc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLIntervalPeriodFilter>;
};
export type GQLStatsGqlPerpOpenInterestArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order?: InputMaybe<GQLStatsPerpOpenInterestOrder>;
    orderDesc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLPeriodFilter>;
};
export type GQLStatsGqlPerpPnlArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order?: InputMaybe<GQLStatsPerpPnlOrder>;
    orderDesc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLPeriodFilter>;
};
export type GQLStatsGqlTotalsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order?: InputMaybe<GQLStatsTotalsOrder>;
    orderDesc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLPeriodFilter>;
};
export type GQLStatsGqlTvlArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order?: InputMaybe<GQLStatsTvlOrder>;
    orderDesc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLPeriodFilter>;
};
export type GQLStatsGqlUsersArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order?: InputMaybe<GQLStatsUsersOrder>;
    orderDesc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLPeriodFilter>;
};
export type GQLStatsGqlVolumeArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    order?: InputMaybe<GQLStatsVolumeOrder>;
    orderDesc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLPeriodFilter>;
};
export type GQLStatsCurrentMetrics = {
    readonly __typename?: 'StatsCurrentMetrics';
    readonly TPS: Scalars['Float']['output'];
    readonly avgBlockDuration: Scalars['Float']['output'];
    readonly block: Scalars['Int']['output'];
    readonly votingPower: GQLStatsVotingPower;
};
export type GQLStatsFees = {
    readonly __typename?: 'StatsFees';
    readonly feesLiquidations: Scalars['Float']['output'];
    readonly feesLiquidationsCumulative: Scalars['Float']['output'];
    readonly feesPerp: Scalars['Float']['output'];
    readonly feesPerpCumulative: Scalars['Float']['output'];
    readonly feesSwap: Scalars['Float']['output'];
    readonly feesSwapCumulative: Scalars['Float']['output'];
    readonly feesTotal: Scalars['Float']['output'];
    readonly feesTotalCumulative: Scalars['Float']['output'];
    /** @deprecated Use periodInterval instead */
    readonly period: Scalars['Int']['output'];
    readonly periodInterval: Scalars['String']['output'];
    readonly periodStartTs: Scalars['Time']['output'];
};
export declare enum GQLStatsFeesOrder {
    GQLFeesLiquidations = "fees_liquidations",
    GQLFeesLiquidationsCumulative = "fees_liquidations_cumulative",
    GQLFeesPerp = "fees_perp",
    GQLFeesPerpCumulative = "fees_perp_cumulative",
    GQLFeesSwap = "fees_swap",
    GQLFeesSwapCumulative = "fees_swap_cumulative",
    GQLFeesTotal = "fees_total",
    GQLFeesTotalCumulative = "fees_total_cumulative",
    GQLPeriod = "period",
    GQLPeriodStartTs = "period_start_ts"
}
export type GQLStatsInflation = {
    readonly __typename?: 'StatsInflation';
    readonly communityPool: Scalars['Float']['output'];
    readonly communityPoolCumulative: Scalars['Float']['output'];
    readonly period: Scalars['String']['output'];
    readonly periodStartTs: Scalars['Time']['output'];
    readonly staking: Scalars['Float']['output'];
    readonly stakingCumulative: Scalars['Float']['output'];
    readonly strategicReserve: Scalars['Float']['output'];
    readonly strategicReserveCumulative: Scalars['Float']['output'];
};
export declare enum GQLStatsInflationOrder {
    GQLCommunityPool = "community_pool",
    GQLCommunityPoolCumulative = "community_pool_cumulative",
    GQLPeriod = "period",
    GQLPeriodStartTs = "period_start_ts",
    GQLStaking = "staking",
    GQLStakingCumulative = "staking_cumulative",
    GQLStrategicReserve = "strategic_reserve",
    GQLStrategicReserveCumulative = "strategic_reserve_cumulative"
}
export type GQLStatsPerpOpenInterest = {
    readonly __typename?: 'StatsPerpOpenInterest';
    readonly openInterestLong: Scalars['Float']['output'];
    readonly openInterestShort: Scalars['Float']['output'];
    readonly openInterestTotal: Scalars['Float']['output'];
    /** @deprecated Use periodInterval instead */
    readonly period: Scalars['Int']['output'];
    readonly periodInterval: Scalars['String']['output'];
    readonly periodStartTs: Scalars['Time']['output'];
};
export declare enum GQLStatsPerpOpenInterestOrder {
    GQLOpenInterestLong = "open_interest_long",
    GQLOpenInterestShort = "open_interest_short",
    GQLOpenInterestTotal = "open_interest_total",
    GQLPeriod = "period",
    GQLPeriodStartTs = "period_start_ts"
}
export type GQLStatsPerpPnl = {
    readonly __typename?: 'StatsPerpPnl';
    readonly loss: Scalars['Float']['output'];
    readonly lossCumulative: Scalars['Float']['output'];
    readonly netPnl: Scalars['Float']['output'];
    readonly netPnlCumulative: Scalars['Float']['output'];
    /** @deprecated Use periodInterval instead */
    readonly period: Scalars['Int']['output'];
    readonly periodInterval: Scalars['String']['output'];
    readonly periodStartTs: Scalars['Time']['output'];
    readonly profit: Scalars['Float']['output'];
    readonly profitCumulative: Scalars['Float']['output'];
};
export declare enum GQLStatsPerpPnlOrder {
    GQLLoss = "loss",
    GQLLossCumulative = "loss_cumulative",
    GQLNetPnl = "net_pnl",
    GQLNetPnlCumulative = "net_pnl_cumulative",
    GQLPeriod = "period",
    GQLPeriodStartTs = "period_start_ts",
    GQLProfit = "profit",
    GQLProfitCumulative = "profit_cumulative"
}
export type GQLStatsTotals = {
    readonly __typename?: 'StatsTotals';
    /** @deprecated Use periodInterval instead */
    readonly period: Scalars['Int']['output'];
    readonly periodInterval: Scalars['String']['output'];
    readonly periodStartTs: Scalars['Time']['output'];
    readonly totalFeesLiquidations: Scalars['Float']['output'];
    readonly totalFeesPerp: Scalars['Float']['output'];
    readonly totalOpenInterest: Scalars['Float']['output'];
    readonly totalPerp: Scalars['Float']['output'];
    readonly totalSwap: Scalars['Float']['output'];
    readonly totalTransactions: Scalars['Int']['output'];
    readonly totalTvl: Scalars['Float']['output'];
};
export declare enum GQLStatsTotalsOrder {
    GQLPeriod = "period",
    GQLPeriodStartTs = "period_start_ts",
    GQLTotalFeesLiquidations = "total_fees_liquidations",
    GQLTotalFeesPerp = "total_fees_perp",
    GQLTotalOpenInterest = "total_open_interest",
    GQLTotalPerp = "total_perp",
    GQLTotalSwap = "total_swap",
    GQLTotalTransactions = "total_transactions",
    GQLTotalTvl = "total_tvl"
}
export type GQLStatsTvl = {
    readonly __typename?: 'StatsTvl';
    /** @deprecated Use periodInterval instead */
    readonly period: Scalars['Int']['output'];
    readonly periodInterval: Scalars['String']['output'];
    readonly periodStartTs: Scalars['Time']['output'];
    readonly tvlPerp: Scalars['Float']['output'];
    readonly tvlStablecoin: Scalars['Float']['output'];
    readonly tvlStaking: Scalars['Float']['output'];
    readonly tvlSwap: Scalars['Float']['output'];
    readonly tvlTotal: Scalars['Float']['output'];
};
export declare enum GQLStatsTvlOrder {
    GQLPeriod = "period",
    GQLPeriodStartTs = "period_start_ts",
    GQLTvlPerp = "tvl_perp",
    GQLTvlStablecoin = "tvl_stablecoin",
    GQLTvlStaking = "tvl_staking",
    GQLTvlSwap = "tvl_swap",
    GQLTvlTotal = "tvl_total"
}
export type GQLStatsUsers = {
    readonly __typename?: 'StatsUsers';
    readonly newAuthUsers: Scalars['Int']['output'];
    readonly newAuthUsersCumulative: Scalars['Int']['output'];
    readonly newUsersLp: Scalars['Int']['output'];
    readonly newUsersLpCumulative: Scalars['Int']['output'];
    readonly newUsersPerp: Scalars['Int']['output'];
    readonly newUsersPerpCumulative: Scalars['Int']['output'];
    readonly newUsersSwap: Scalars['Int']['output'];
    readonly newUsersSwapCumulative: Scalars['Int']['output'];
    readonly newUsersTotal: Scalars['Int']['output'];
    readonly newUsersTotalCumulative: Scalars['Int']['output'];
    /** @deprecated Use periodInterval instead */
    readonly period: Scalars['Int']['output'];
    readonly periodInterval: Scalars['String']['output'];
    readonly periodStartTs: Scalars['Time']['output'];
    readonly uniqueUsersLp: Scalars['Int']['output'];
    readonly uniqueUsersPerp: Scalars['Int']['output'];
    readonly uniqueUsersSwap: Scalars['Int']['output'];
    readonly uniqueUsersTotal: Scalars['Int']['output'];
    readonly userActionsLp: Scalars['Int']['output'];
    readonly userActionsPerp: Scalars['Int']['output'];
    readonly userActionsSwap: Scalars['Int']['output'];
    readonly userActionsTotal: Scalars['Int']['output'];
};
export declare enum GQLStatsUsersOrder {
    GQLNewAuthUsers = "new_auth_users",
    GQLNewAuthUsersCumulative = "new_auth_users_cumulative",
    GQLNewUsersLp = "new_users_lp",
    GQLNewUsersLpCumulative = "new_users_lp_cumulative",
    GQLNewUsersPerp = "new_users_perp",
    GQLNewUsersPerpCumulative = "new_users_perp_cumulative",
    GQLNewUsersSwap = "new_users_swap",
    GQLNewUsersSwapCumulative = "new_users_swap_cumulative",
    GQLNewUsersTotal = "new_users_total",
    GQLNewUsersTotalCumulative = "new_users_total_cumulative",
    GQLPeriod = "period",
    GQLPeriodStartTs = "period_start_ts",
    GQLUniqueUsersLp = "unique_users_lp",
    GQLUniqueUsersPerp = "unique_users_perp",
    GQLUniqueUsersSwap = "unique_users_swap",
    GQLUniqueUsersTotal = "unique_users_total",
    GQLUserActionsLp = "user_actions_lp",
    GQLUserActionsPerp = "user_actions_perp",
    GQLUserActionsSwap = "user_actions_swap",
    GQLUserActionsTotal = "user_actions_total"
}
export type GQLStatsVolume = {
    readonly __typename?: 'StatsVolume';
    /** @deprecated Use periodInterval instead */
    readonly period: Scalars['Int']['output'];
    readonly periodInterval: Scalars['String']['output'];
    readonly periodStartTs: Scalars['Time']['output'];
    readonly volumePerp: Scalars['Float']['output'];
    readonly volumePerpCumulative: Scalars['Float']['output'];
    readonly volumeSwap: Scalars['Float']['output'];
    readonly volumeSwapCumulative: Scalars['Float']['output'];
    readonly volumeTotal: Scalars['Float']['output'];
    readonly volumeTotalCumulative: Scalars['Float']['output'];
};
export declare enum GQLStatsVolumeOrder {
    GQLPeriod = "period",
    GQLPeriodStartTs = "period_start_ts",
    GQLVolumePerp = "volume_perp",
    GQLVolumePerpCumulative = "volume_perp_cumulative",
    GQLVolumeSwap = "volume_swap",
    GQLVolumeSwapCumulative = "volume_swap_cumulative",
    GQLVolumeTotal = "volume_total",
    GQLVolumeTotalCumulative = "volume_total_cumulative"
}
export type GQLStatsVotingPower = {
    readonly __typename?: 'StatsVotingPower';
    readonly active: Scalars['Int']['output'];
    readonly missing: Scalars['Int']['output'];
    readonly unknown: Scalars['Int']['output'];
};
export type GQLStringFilter = {
    readonly eq?: InputMaybe<Scalars['String']['input']>;
    readonly like?: InputMaybe<Scalars['String']['input']>;
};
export type GQLSubMarkPriceCandlesFilter = {
    readonly pairEq: Scalars['String']['input'];
    readonly periodEq: Scalars['Int']['input'];
};
export type GQLSubOraclePricesFilter = {
    readonly pair: Scalars['String']['input'];
};
export type GQLSubPerpMarketFilter = {
    readonly pair: Scalars['String']['input'];
};
export type GQLSubPerpPositionFilter = {
    readonly pair?: InputMaybe<Scalars['String']['input']>;
    readonly trader_address: Scalars['String']['input'];
};
export type GQLSubscription = {
    readonly __typename?: 'Subscription';
    readonly markPriceCandles: ReadonlyArray<GQLMarkPriceCandle>;
    readonly oraclePrices: ReadonlyArray<GQLOraclePrice>;
    readonly perpMarket: GQLPerpMarket;
    readonly perpPositions: ReadonlyArray<GQLPerpPosition>;
};
export type GQLSubscriptionGqlMarkPriceCandlesArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    where: GQLSubMarkPriceCandlesFilter;
};
export type GQLSubscriptionGqlOraclePricesArgs = {
    where?: InputMaybe<GQLSubOraclePricesFilter>;
};
export type GQLSubscriptionGqlPerpMarketArgs = {
    where: GQLSubPerpMarketFilter;
};
export type GQLSubscriptionGqlPerpPositionsArgs = {
    where: GQLSubPerpPositionFilter;
};
export type GQLTimeFilter = {
    readonly eq?: InputMaybe<Scalars['Time']['input']>;
    readonly gt?: InputMaybe<Scalars['Time']['input']>;
    readonly gte?: InputMaybe<Scalars['Time']['input']>;
    readonly lt?: InputMaybe<Scalars['Time']['input']>;
    readonly lte?: InputMaybe<Scalars['Time']['input']>;
};
export type GQLToken = {
    readonly __typename?: 'Token';
    readonly amount: Scalars['String']['output'];
    readonly denom: Scalars['String']['output'];
};
export type GQLUnbonding = {
    readonly __typename?: 'Unbonding';
    readonly amount: Scalars['Int']['output'];
    readonly completion_time: Scalars['String']['output'];
    readonly creation_block: GQLBlock;
    readonly delegator: GQLUser;
    readonly validator: GQLValidator;
};
export type GQLUnbondingFilter = {
    readonly delegator_address?: InputMaybe<Scalars['String']['input']>;
    readonly validator_address?: InputMaybe<Scalars['String']['input']>;
};
export declare enum GQLUnbondingOrder {
    GQLCompletionTime = "completion_time",
    GQLCreationHeight = "creation_height",
    GQLDelegatorAddress = "delegator_address",
    GQLValidatorAddress = "validator_address"
}
export type GQLUser = {
    readonly __typename?: 'User';
    readonly address: Scalars['String']['output'];
    readonly balances: ReadonlyArray<Maybe<GQLToken>>;
    readonly created_block: GQLBlock;
    readonly is_blocked?: Maybe<Scalars['Boolean']['output']>;
};
export type GQLUserContract = {
    readonly __typename?: 'UserContract';
    readonly contractAddress: Scalars['String']['output'];
    readonly contractType: Scalars['String']['output'];
    readonly events?: Maybe<ReadonlyArray<GQLEvent>>;
    readonly user: GQLUser;
};
export type GQLUserContractsFilter = {
    readonly contractAddress?: InputMaybe<GQLStringFilter>;
    readonly contractType?: InputMaybe<GQLStringFilter>;
    readonly userAddress?: InputMaybe<GQLStringFilter>;
};
export declare enum GQLUserContractsOrder {
    GQLContractAddress = "contract_address",
    GQLContractType = "contract_type",
    GQLUserAddress = "user_address"
}
export type GQLUserFilter = {
    readonly address: Scalars['String']['input'];
};
export declare enum GQLUserOrder {
    GQLAddress = "address",
    GQLCreatedBlock = "created_block"
}
export type GQLUsersFilter = {
    readonly address?: InputMaybe<Scalars['String']['input']>;
    readonly created_block_eq?: InputMaybe<Scalars['Int']['input']>;
    readonly created_block_gte?: InputMaybe<Scalars['Int']['input']>;
    readonly created_block_lte?: InputMaybe<Scalars['Int']['input']>;
};
export type GQLValidator = {
    readonly __typename?: 'Validator';
    readonly commission_rates?: Maybe<GQLValidatorCommission>;
    readonly commission_update_time: Scalars['String']['output'];
    readonly creation_block: GQLBlock;
    readonly delegator_shares: Scalars['Float']['output'];
    readonly description: GQLValidatorDescription;
    readonly jailed: Scalars['Boolean']['output'];
    readonly min_self_delegation: Scalars['Int']['output'];
    readonly operator_address: Scalars['String']['output'];
    readonly self_delegation: Scalars['Int']['output'];
    readonly status: GQLValidatorStatus;
    readonly tokens: Scalars['Int']['output'];
    readonly unbonding_block: GQLBlock;
    readonly unbonding_time: Scalars['String']['output'];
    readonly uptime?: Maybe<Scalars['Float']['output']>;
};
export type GQLValidatorCommission = {
    readonly __typename?: 'ValidatorCommission';
    readonly max_change_rate: Scalars['Float']['output'];
    readonly max_rate: Scalars['Float']['output'];
    readonly rate: Scalars['Float']['output'];
};
export type GQLValidatorDescription = {
    readonly __typename?: 'ValidatorDescription';
    readonly details: Scalars['String']['output'];
    readonly identity: Scalars['String']['output'];
    readonly moniker: Scalars['String']['output'];
    readonly security_contact: Scalars['String']['output'];
    readonly website: Scalars['String']['output'];
};
export type GQLValidatorFilter = {
    readonly jailed?: InputMaybe<Scalars['Boolean']['input']>;
    readonly moniker?: InputMaybe<Scalars['String']['input']>;
    readonly operator_address?: InputMaybe<Scalars['String']['input']>;
    readonly status?: InputMaybe<GQLValidatorStatus>;
};
export declare enum GQLValidatorOrder {
    GQLJailed = "jailed",
    GQLMoniker = "moniker",
    GQLOperatorAddress = "operator_address",
    GQLStatus = "status",
    GQLTokens = "tokens"
}
export declare enum GQLValidatorStatus {
    GQLBonded = "BONDED",
    GQLUnbonded = "UNBONDED",
    GQLUnbonding = "UNBONDING"
}
export type GQLWasm = {
    readonly __typename?: 'Wasm';
    readonly contractEvents: ReadonlyArray<GQLEvent>;
    readonly userContracts: ReadonlyArray<GQLUserContract>;
};
export type GQLWasmGqlContractEventsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order?: InputMaybe<GQLContractEventsOrder>;
    orderDesc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLContractEventsFilter>;
};
export type GQLWasmGqlUserContractsArgs = {
    limit?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    order?: InputMaybe<GQLUserContractsOrder>;
    orderDesc?: InputMaybe<Scalars['Boolean']['input']>;
    where?: InputMaybe<GQLUserContractsFilter>;
};
//# sourceMappingURL=generated.d.ts.map