"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const proto_signing_1 = require("@cosmjs/proto-signing");
const __1 = require("..");
describe("chain/chain", () => {
    test("testnet rpc", () => __awaiter(void 0, void 0, void 0, function* () {
        const sgClient = yield __1.NibiruTxClient.connect(__1.Localnet.endptTm);
        const blockHeight = yield sgClient.getHeight();
        expect(blockHeight).toBeDefined();
        expect(blockHeight).toBeGreaterThanOrEqual(0);
    }));
    test("chain from chain-id", () => __awaiter(void 0, void 0, void 0, function* () {
        const chain = __1.CustomChain.fromChainId(__1.Localnet.chainId);
        expect(chain.chainId).toEqual(__1.Localnet.chainId);
    }));
    const expectCreatedChain = (result, shortName, num) => {
        expect(result.chainId).toEqual(`nibiru-${shortName}-${num}`);
        expect(result.chainName).toEqual(`nibiru-${shortName}-${num}`);
        expect(result.endptGrpc).toEqual(`grpc.${shortName}-${num}.nibiru.fi`);
        expect(result.endptRest).toEqual(`https://lcd.${shortName}-${num}.nibiru.fi`);
        expect(result.endptTm).toEqual(`https://rpc.${shortName}-${num}.nibiru.fi`);
        expect(result.endptHm).toEqual(`https://hm-graphql.${shortName}-${num}.nibiru.fi/query`);
        expect(result.endptWs).toEqual(`wss://hm-graphql.${shortName}-${num}.nibiru.fi/query`);
        expect(result.feeDenom).toEqual(`unibi`);
    };
    test("IncentivizedTestnet", () => __awaiter(void 0, void 0, void 0, function* () {
        const num = 1;
        const result = (0, __1.Testnet)(num);
        expectCreatedChain(result, "testnet", num);
    }));
    test("IncentivizedTestnet - no params", () => __awaiter(void 0, void 0, void 0, function* () {
        const result = (0, __1.Testnet)();
        expectCreatedChain(result, "testnet", 1);
    }));
    test("Devnet", () => __awaiter(void 0, void 0, void 0, function* () {
        const num = 2;
        const result = (0, __1.Devnet)(num);
        expectCreatedChain(result, "devnet", num);
    }));
    test("Mainnet", () => {
        const result = (0, __1.Mainnet)();
        const shortName = "cataclysm";
        const number = 1;
        expect(result.chainId).toEqual(`${shortName}-${number}`);
        expect(result.chainName).toEqual(`${shortName}-${number}`);
        expect(result.endptGrpc).toEqual(`grpc.nibiru.fi`);
        expect(result.endptRest).toEqual(`https://lcd.nibiru.fi`);
        expect(result.endptTm).toEqual(`https://rpc.nibiru.fi`);
        expect(result.endptHm).toEqual(`https://hm-graphql.nibiru.fi/query`);
        expect(result.endptWs).toEqual(`wss://hm-graphql.nibiru.fi/query`);
        expect(result.feeDenom).toEqual(`unibi`);
    });
    test("queryChainIdWithRest", () => __awaiter(void 0, void 0, void 0, function* () {
        const chain = __1.Localnet;
        const result = yield (0, __1.queryChainIdWithRest)(chain);
        expect(result.ok).toEqual("nibiru-localnet-0");
    }));
    test("inactive chain validation cases", () => __awaiter(void 0, void 0, void 0, function* () {
        const inactiveChain = {
            endptTm: "",
            endptRest: "",
            endptGrpc: "",
            endptHm: "",
            endptWs: "",
            chainId: "chain-id",
            chainName: "inactive-chain",
            feeDenom: "unibi",
        };
        const res = yield (0, __1.queryChainIdWithRest)(inactiveChain);
        expect(res.isErr()).toBeDefined();
        yield expect((0, __1.isRestEndptLive)(inactiveChain)).resolves.toBeFalsy();
    }));
    test("chainToParts", () => {
        const chain = (0, __1.Devnet)(2);
        const result = (0, __1.chainToParts)(chain);
        expect(result).toEqual({ prefix: "nibiru", shortName: "devnet", number: 2 });
    });
});
describe("chain/parse", () => {
    test("fromSdkInt", () => {
        const result = (0, __1.fromSdkInt)("123456789.987654321");
        expect(result).toEqual(123456789);
    });
    const fromSdkDecTests = () => {
        const tests = [
            {
                name: "fromSdkDec number with decimal",
                in: "12345678.9987654321",
            },
            {
                name: "fromSdkDec NaN",
                in: "$$$",
            },
        ];
        test.each(tests)("%o", (tt) => {
            const res = (0, __1.fromSdkDec)(tt.in);
            expect(res).toBe(0);
        });
    };
    const toSdkDecTests = () => {
        const tests = [
            {
                name: "toSdkDec empty string",
                in: "",
                expected: "0",
            },
            {
                name: "toSdkDec negative zero",
                in: "-0",
                expected: "-0000000000000000000",
            },
            {
                name: "toSdkDec negative",
                in: "-",
                expected: "0",
            },
            {
                name: "toSdkDec NaN",
                in: "$$$",
                expected: "0",
            },
            {
                name: "toSdkDec multi-decimal",
                in: "1.1.1",
                expected: "0",
            },
            {
                name: "toSdkDec no leading zero",
                in: ".1",
                expected: "0",
            },
            {
                name: "toSdkDec why handling with bignumber is better",
                in: "0.232423423423423423434234234234234234234234234234234234234234231",
                expected: "0",
            },
        ];
        test.each(tests)("%o", (tt) => {
            const res = (0, __1.toSdkDec)(tt.in);
            expect(res).toBe(tt.expected);
        });
    };
    toSdkDecTests();
    fromSdkDecTests();
});
describe("chain/types", () => {
    const coinsIn = [
        (0, proto_signing_1.coin)(10, "unusd"),
        (0, proto_signing_1.coin)(50, "unibi"),
        { amount: "42.42", denom: "uatom" },
        { amount: "16800456610195729831", denom: "nibiru/pool/2" },
        { denom: "unibi2", amount: "21519262" },
    ];
    test("coin map fns", () => {
        const coins = (0, __1.newCoinMapFromCoins)(coinsIn);
        expect(coins.unusd.toString()).toBe("10");
        expect(coins.unibi.toString()).toBe("50");
        expect(coins.uatom.toString()).toBe("42.42");
        expect(coins.unibi2.toString()).toBe("21519262");
        expect(coins["nibiru/pool/2"].toString()).toBe("16800456610195729831");
    });
});
test("custom assert fn", () => {
    expect((0, __1.assert)(false)).toEqual("AssertionError");
    const err = "useful error message";
    expect((0, __1.assert)(false, err)).toEqual(`AssertionError: ${err}`);
});
//# sourceMappingURL=chain.test.js.map