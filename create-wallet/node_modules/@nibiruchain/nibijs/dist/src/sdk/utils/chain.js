"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.chainToParts = exports.isRestEndptLive = exports.queryChainIdWithRest = exports.Mainnet = exports.Devnet = exports.IncentivizedTestnet = exports.Testnet = exports.Localnet = exports.CustomChain = void 0;
const cross_fetch_1 = require("cross-fetch");
const _1 = require(".");
/** CustomChain is a convenience class for intializing the endpoints of a chain
 * based on its chain ID.
 *
 * @example
 * ```ts
 * export const chain = new CustomChain({
 *   prefix: "nibiru",
 *   shortName: "testnet",
 *   number: 1,
 * })
 * ```
 */
class CustomChain {
    constructor(chainIdParts) {
        this.feeDenom = "unibi";
        this.initChainId = () => {
            const { prefix, shortName, number } = this.chainIdParts;
            return [prefix, shortName, number]
                .filter((v) => Boolean(v) || Number(v) === 0)
                .join("-");
        };
        this.chainIdParts = chainIdParts;
        this.chainId = this.initChainId();
        this.chainName = this.chainId;
        const chainEndpt = chainIdParts.mainnet
            ? ""
            : `.${chainIdParts.shortName}-${chainIdParts.number}`;
        this.endptTm = `https://rpc${chainEndpt}.nibiru.fi`;
        this.endptRest = `https://lcd${chainEndpt}.nibiru.fi`;
        this.endptGrpc = `grpc${chainEndpt}.nibiru.fi`;
        this.endptHm = `https://hm-graphql${chainEndpt}.nibiru.fi/query`;
        this.endptWs = `wss://hm-graphql${chainEndpt}.nibiru.fi/query`;
    }
    static fromChainId(chainId) {
        const parts = chainId.split("-");
        const chainIdParts = {
            prefix: parts[0],
            shortName: parts[1],
            number: parseInt(parts[2]),
        };
        return new CustomChain(chainIdParts);
    }
}
exports.CustomChain = CustomChain;
/** Localnet: "Chain" configuration for a local Nibiru network. A local
 * environment is no different from a real one, except that it has a single
 * validator running on your host machine. Localnet is primarily used as a
 * controllable, isolated development environment for testing purposes. */
exports.Localnet = {
    endptTm: "http://127.0.0.1:26657",
    endptRest: "http://127.0.0.1:1317",
    endptGrpc: "http://127.0.0.1:9090",
    endptHm: "http://127.0.0.1:5555/query",
    endptWs: "ws://127.0.0.1:5555/query",
    chainId: "nibiru-localnet-0",
    chainName: "Nibiru Localnet (Default)",
    feeDenom: "unibi",
};
/** Testnet: "Chain" configuration for a Nibiru testnet. These are public
 * networks that are upgraded in advance of Nibiru's mainnet network as a
 * beta-testing environments.
 *
 * For an updated list of active networks, see:
 *
 * - <a href="https://nibiru.fi/docs/">Nibiru Networks | Nibiru Docs (Recommended)</a>
 * - <a href="https://github.com/NibiruChain/Networks/tree/main">NibiruChain/Networks (GitHub)</a>
 *
 * By default, the "Testnet" function returns the permanent testnet if no
 * arguments are passed.
 * */
const Testnet = (chainNumber = 1) => new CustomChain({
    prefix: "nibiru",
    shortName: "testnet",
    number: chainNumber,
});
exports.Testnet = Testnet;
/** @deprecated Incentivized testnet is no longer active. This variable exists
 * for backwards compatibility, but "Testnet" should be used instead.
 *
 * @see Testnet - Permanent Nibiru public test network.
 */
exports.IncentivizedTestnet = exports.Testnet;
/** Devnet: "Chain" configuration for a Nibiru "devnet". These networks
 * are more ephemeral than "Testnet" and used internally by the core Nibiru
 * dev team to live-test new features before official public release.
 * */
const Devnet = (chainNumber) => new CustomChain({
    prefix: "nibiru",
    shortName: "devnet",
    number: chainNumber,
});
exports.Devnet = Devnet;
/** Mainnet: "Chain" configuration for the Nibiru "mainnet".
 * ‚ùó Mainnet uses real funds. For more info, see
 * <a href="https://nibiru.fi/docs/dev/networks/">Nibiru Netwokrs</a>.
 * */
const Mainnet = (chainNumber = 1) => new CustomChain({
    shortName: "cataclysm",
    number: chainNumber,
    mainnet: true,
});
exports.Mainnet = Mainnet;
const queryChainIdWithRest = (chain) => __awaiter(void 0, void 0, void 0, function* () {
    const queryChainId = (chain) => __awaiter(void 0, void 0, void 0, function* () {
        const response = yield (0, cross_fetch_1.fetch)(`${chain.endptRest}/cosmos/base/tendermint/v1beta1/node_info`);
        const nodeInfo = yield response.json();
        return nodeInfo.default_node_info.network;
    });
    return _1.Result.ofSafeExecAsync(() => __awaiter(void 0, void 0, void 0, function* () { return queryChainId(chain); }));
});
exports.queryChainIdWithRest = queryChainIdWithRest;
/** isRestEndptLive: Makes a request using the chain's REST endpoint to see if
 * the network and endpoint are active. */
const isRestEndptLive = (chain) => __awaiter(void 0, void 0, void 0, function* () {
    const res = yield (0, exports.queryChainIdWithRest)(chain);
    return res.isOk();
});
exports.isRestEndptLive = isRestEndptLive;
/**
 * Converts a Chain object to its constituent parts.
 * @param chain a Chain object
 * @returns a ChainIdParts object
 */
const chainToParts = (chain) => {
    const parts = chain.chainId.split("-");
    return {
        prefix: parts[0],
        shortName: parts[1],
        number: Number(parts[2]),
    };
};
exports.chainToParts = chainToParts;
//# sourceMappingURL=chain.js.map