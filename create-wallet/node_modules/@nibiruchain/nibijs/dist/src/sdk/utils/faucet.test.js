"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const stargate_1 = require("@cosmjs/stargate");
const proto_signing_1 = require("@cosmjs/proto-signing");
const cross_fetch_1 = require("cross-fetch");
const __1 = require("..");
jest.mock("cross-fetch", () => ({
    fetch: jest.fn().mockImplementation(() => ({ catch: jest.fn() })),
}));
// We can't create a test token even with faked recaptcha site
// and secret tokens. This not only would require a setup to generate
// a token from the UI, but to also create a fake backend
// recaptcha check with a test secret.
// In this case, this test can be skipped and checked it manually.
// eslint-disable-next-line jest/no-disabled-tests
test.skip("faucet utility works", () => __awaiter(void 0, void 0, void 0, function* () {
    const wallet = yield (0, __1.newRandomWallet)();
    const [{ address: toAddr }] = yield wallet.getAccounts();
    const validator = yield (0, __1.newSignerFromMnemonic)(__1.TEST_MNEMONIC);
    const txClient = yield __1.NibiruTxClient.connectWithSigner(__1.Localnet.endptTm, validator);
    const [{ address: fromAddr }] = yield validator.getAccounts();
    yield txClient.waitForNextBlock();
    const txResp = yield txClient.sendTokens(fromAddr, toAddr, (0, proto_signing_1.coins)(100, "unibi"), "auto");
    (0, stargate_1.assertIsDeliverTxSuccess)(txResp);
    const balancesStart = (0, __1.newCoinMapFromCoins)(yield txClient.getAllBalances(toAddr));
    const faucetResp = yield (0, __1.useFaucet)({
        address: toAddr,
        chain: __1.Localnet,
        grecaptcha: "",
    });
    expect(faucetResp === null || faucetResp === void 0 ? void 0 : faucetResp.ok).toBeTruthy();
    const balancesEnd = (0, __1.newCoinMapFromCoins)(yield txClient.getAllBalances(toAddr));
    expect(balancesEnd.unusd.minus(balancesStart.unusd).eq(100 * 1e6)).toBeTruthy();
    expect(balancesEnd.unibi.minus(balancesStart.unibi).eq(11 * 1e6)).toBeTruthy();
}), 60000); // 60 seconds
describe("useFaucet", () => {
    const chain = {
        endptTm: "",
        endptRest: "",
        endptGrpc: "",
        endptHm: "",
        endptWs: "",
        chainId: "nibiru-testnet-1",
        chainName: "",
        feeDenom: "",
    };
    const grecaptcha = "TEST_GRECAPTCHA_TOKEN";
    const address = "0x1234567890";
    const expectedUrl = "https://faucet.testnet-1.nibiru.fi/";
    test("should request funds from faucet with default amounts", () => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, __1.useFaucet)({ address, chain, grecaptcha });
        const expectedCoins = ["11000000unibi", "100000000unusd", "100000000uusdt"];
        expect(cross_fetch_1.fetch).toHaveBeenCalledWith(expectedUrl, {
            method: "POST",
            headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
            },
            body: JSON.stringify({ address, coins: expectedCoins, grecaptcha }),
        });
    }));
    test("should request funds from faucet with custom amounts", () => __awaiter(void 0, void 0, void 0, function* () {
        const amts = { nibi: 5, nusd: 50, usdt: 50 };
        yield (0, __1.useFaucet)({ address, chain, amts, grecaptcha });
        const expectedCoins = ["5000000unibi", "50000000unusd", "50000000uusdt"];
        expect(cross_fetch_1.fetch).toHaveBeenCalledWith(expectedUrl, {
            method: "POST",
            headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
            },
            body: JSON.stringify({ address, coins: expectedCoins, grecaptcha }),
        });
    }));
    test("faucetUrlFromChain helper func should construct faucet URL from chain object", () => {
        expect((0, __1.faucetUrlFromChain)({
            endptTm: "",
            endptRest: "",
            endptGrpc: "",
            endptHm: "",
            endptWs: "",
            chainId: "nibiru-testnet-1",
            chainName: "",
            feeDenom: "",
        })).toBe(expectedUrl);
    });
    test("faucetUrlFromChain - chain includes cataclysm", () => {
        const result = (0, __1.faucetUrlFromChain)({
            endptTm: "",
            endptRest: "",
            endptGrpc: "",
            endptHm: "",
            endptWs: "",
            chainId: "",
            chainName: "cataclysm",
            feeDenom: "",
        });
        expect(result).toEqual(`https://faucet.nibiru.fi/`);
    });
});
//# sourceMappingURL=faucet.test.js.map