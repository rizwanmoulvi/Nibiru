"use strict";
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertExpectedError = exports.assertHasEventType = exports.assertHasMsgType = exports.assertValidBlock = exports.assertValidBlockFromJsonRpc = exports.ERR = exports.TEST_ADDRESS = exports.TEST_MNEMONIC = void 0;
const __1 = require("..");
/** Mnemonic for the wallet of the default validator on localnet" */
exports.TEST_MNEMONIC = (_a = process.env.VALIDATOR_MNEMONIC) !== null && _a !== void 0 ? _a : "guard cream sadness conduct invite crumble clock pudding hole grit liar hotel maid produce squeeze return argue turtle know drive eight casino maze host";
/** Address for the wallet of the default validator on localnet" */
exports.TEST_ADDRESS = (_b = process.env.VALIDATOR_ADDRESS) !== null && _b !== void 0 ? _b : "nibi1zaavvzxez0elundtn32qnk9lkm8kmcsz44g7xl";
exports.ERR = {
    collections: "collections: not found",
    sequence: "account sequence mismatch",
    noPrices: "no valid prices available",
};
/** Validates that block queried via the JSON RPC client has the expected fields. */
function assertValidBlockFromJsonRpc(blockJson) {
    const blockSchema = {
        header: ["version", "chain_id", "height", "last_block_id"].concat(["last_commit_hash", "data_hash", "validators_hash"], ["consensus_hash", "app_hash", "last_results_hash", "evidence_hash"], ["proposer_address", "next_validators_hash"]),
        data: ["txs"],
        evidence: ["evidence"],
        last_commit: ["height", "round", "block_id", "signatures"],
    };
    for (const attr in blockSchema) {
        expect(blockJson).toHaveProperty(attr);
        const blockSchemaAtAttr = blockSchema[attr];
        for (const subAttr of blockSchemaAtAttr) {
            expect(blockJson[attr]).toHaveProperty(subAttr);
        }
    }
}
exports.assertValidBlockFromJsonRpc = assertValidBlockFromJsonRpc;
/** assertValidBlock: Performs runtime type validation on a CometBFT "Block". */
function assertValidBlock(block, chain) {
    expect(block.header.chainId).toEqual(chain.chainId);
    expect(block.header.time).toBeDefined();
    expect(block.header.height).toBeGreaterThanOrEqual(1);
    expect(block).toHaveProperty("txs");
}
exports.assertValidBlock = assertValidBlock;
/**
 * Asserts that a list of ABCIEvents contains a specific type of `TxMsg`. This
 * `TxMsg` type is read from a "message" event's "action" attribute.
 *
 * @param {string} msgType - TxMsg type to look for within the event attributes.
 * @param {ABCIEvent[]} events - set of events over which we're searching.
 */
function assertHasMsgType(msgType, events) {
    events.forEach((event) => {
        if (event.type === "message") {
            expect(event.attributes).toContainEqual({
                key: "action",
                value: msgType,
            });
        }
    });
}
exports.assertHasMsgType = assertHasMsgType;
/**
 * Asserts that an array of ABCIEvent objects contains an event with a specified
 * type. This runs a test expectation that the specified `eventType` is
 * contained in `events`.
 *
 * @param {string} eventType - The event type to look for in the array of events.
 * @param {ABCIEvent[]} events - An array of ABCIEvent objects to be tested.
 */
function assertHasEventType(eventType, events) {
    const eventTypes = events.map((event) => event.type);
    expect(eventTypes).toContain(eventType);
}
exports.assertHasEventType = assertHasEventType;
/**
 * Asserts that the given error matches one of the expected error messages.
 *
 * This function parses the error object to extract its message and checks if
 * it includes any of the specified acceptable error messages. It sets a test
 * expectation that the error message is contained within the list of acceptable errors.
 *
 * @param {unknown} err - The error object to be tested.
 * @param {string[]} okErrors - An array of acceptable error message strings.
 */
const assertExpectedError = (err, okErrors) => {
    let isContained = false;
    const errMsg = (0, __1.parseError)(err).message;
    okErrors.forEach((e) => {
        if (errMsg.includes(e)) {
            isContained = true;
        }
    });
    expect(isContained).toBeTruthy();
};
exports.assertExpectedError = assertExpectedError;
//# sourceMappingURL=testutil.js.map