import { BigNumber } from "bignumber.js";
/**
 * StableSwap contains the logic for exchanging tokens
 *
 * Based on: https://github.com/NibiruChain/nibiru/blob/master/contrib/scripts/testing/stableswap_model.py
 *
 * Constructor:
 * @param {BigNumber} Amplification
 * @param {BigNumber[]} totalTokenSupply
 * @param {BigNumber[]} tokenPrices
 * @param {BigNumber} fee
 *
 * @export
 * @class StableSwap
 */
export declare class StableSwap {
    Amplification: BigNumber;
    totalTokenSupply: BigNumber[];
    totalTokensInPool: BigNumber;
    fee: BigNumber;
    constructor(Amplification: BigNumber, totalTokenSupply: BigNumber[], fee: BigNumber);
    /**
     * xp() gives an array of total tokens
     *
     * @memberof StableSwap
     */
    xp(): BigNumber[];
    /**
     * D()
     *
     * D invariant calculation in non-overflowing integer operations iteratively
     * A * sum(x_i) * n**n + D = A * D * n**n + D**(n+1) / (n**n * prod(x_i))
     *
     *
     * @memberof StableSwap
     */
    D(): BigNumber;
    /**
     * y()
     *
     * Calculate x[j] if one makes x[i] = x
     *
     * Done by solving quadratic equation iteratively.
     *  x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n+1)/(n ** (2 * n) * prod' * A)
     *  x_1**2 + b*x_1 = c
     *
     *  x_1 = (x_1**2 + c) / (2*x_1 + b)
     *
     * @param {number} fromIndex
     * @param {number} toIndex
     * @param {BigNumber} x
     * @memberof StableSwap
     */
    y(fromIndex: number, toIndex: number, x: BigNumber): BigNumber;
    /**
     * exchange() runs a theorhetical Curve StableSwap model to determine impact on token price
     *
     * @param {number} fromIndex
     * @param {number} toIndex
     * @param {BigNumber} dx
     * @memberof StableSwap
     */
    exchange(fromIndex: number, toIndex: number, dx: BigNumber): BigNumber;
}
//# sourceMappingURL=stableswap.d.ts.map