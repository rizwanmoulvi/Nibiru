"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const proto_signing_1 = require("@cosmjs/proto-signing");
const _1 = require(".");
describe("signer tests", () => {
    test("getRegistry", () => {
        const testResult = (0, _1.getRegistry)();
        expect(testResult).toBeInstanceOf(proto_signing_1.Registry);
        expect(testResult.encode).toBeTruthy();
        expect(testResult.decode).toBeTruthy();
        expect(testResult.decodeTxBody).toBeTruthy();
        expect(testResult.encodeAsAny).toBeTruthy();
        expect(testResult.encodeTxBody).toBeTruthy();
        expect(testResult.lookupType).toBeTruthy();
        expect(testResult.register).toBeTruthy();
    });
    test("newSignerFromMnemonic", () => __awaiter(void 0, void 0, void 0, function* () {
        const mnemonic = "guard cream sadness conduct invite crumble clock pudding hole grit liar hotel maid produce squeeze return argue turtle know drive eight casino maze host";
        const testResult = yield (0, _1.newSignerFromMnemonic)(mnemonic);
        expect(testResult).toBeInstanceOf(proto_signing_1.DirectSecp256k1HdWallet);
        expect(testResult.getAccounts).toBeTruthy();
        expect(testResult.mnemonic).toEqual(mnemonic);
        expect(testResult.serialize).toBeTruthy();
        expect(testResult.serializeWithEncryptionKey).toBeTruthy();
        expect(testResult.signDirect).toBeTruthy();
    }));
    test("newRandomWallet", () => __awaiter(void 0, void 0, void 0, function* () {
        const testResult = yield (0, _1.newRandomWallet)();
        expect(testResult).toBeInstanceOf(proto_signing_1.DirectSecp256k1HdWallet);
        expect(testResult.getAccounts).toBeTruthy();
        expect(testResult.mnemonic).toBeTruthy();
        expect(testResult.serialize).toBeTruthy();
        expect(testResult.serializeWithEncryptionKey).toBeTruthy();
        expect(testResult.signDirect).toBeTruthy();
    }));
});
test("newRandomWallet", () => __awaiter(void 0, void 0, void 0, function* () {
    const wallet = yield (0, _1.newRandomWallet)(24);
    const [{ address }] = yield wallet.getAccounts();
    expect(address).toHaveLength(43);
    expect(wallet.mnemonic.split(" ")).toHaveLength(24);
}));
// ANKI HD wallet is heirarchical deterministic
// NOTEs see https://www.investopedia.com/terms/h/hd-wallet-hierarchical-deterministic-wallet.asp#:~:text=A%20hierarchical%20deterministic%20(HD)%20wallet%20is%20a%20digital%20wallet%20commonly,the%20cryptocurrency%20in%20the%20account.
test("newSignerFromMnemonic", () => __awaiter(void 0, void 0, void 0, function* () {
    const mnemonic = "honey club license water device crew gap hidden prize debate enhance true absent vibrant image pitch audit beef ability shadow dog label fetch cup";
    const addressForMnemonic = "nibi1qdk4jkwghcq7lz9uf28tf3qcy3appa42k8wxzg";
    const wallet = yield (0, _1.newSignerFromMnemonic)(mnemonic);
    const [{ address }] = yield wallet.getAccounts();
    expect(address).toEqual(addressForMnemonic);
}));
//# sourceMappingURL=signer.test.js.map