"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const proto_signing_1 = require("@cosmjs/proto-signing");
const stargate_1 = require("@cosmjs/stargate");
const __1 = require("..");
describe("txClient", () => {
    test("connects", () => __awaiter(void 0, void 0, void 0, function* () {
        const txClient = yield __1.NibiruTxClient.connect(__1.Localnet.endptTm);
        expect(txClient).toBeTruthy();
    }));
});
describe("nibid tx bank send", () => {
    // TODO: Refactor for concurrency
    test.skip("send tokens from the devnet genesis validator to a random account", () => __awaiter(void 0, void 0, void 0, function* () {
        const signer = yield (0, __1.newSignerFromMnemonic)(__1.TEST_MNEMONIC);
        const [{ address: fromAddr }] = yield signer.getAccounts();
        expect(fromAddr).toBeDefined();
        const txClient = yield __1.NibiruTxClient.connectWithSigner(__1.Localnet.endptTm, signer);
        const toWallet = yield (0, __1.newRandomWallet)();
        const [{ address: toAddr }] = yield toWallet.getAccounts();
        const resp = yield txClient.sendTokens(fromAddr, toAddr, (0, proto_signing_1.parseCoins)("1unibi"), 400000);
        (0, stargate_1.assertIsDeliverTxSuccess)(resp);
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const txQuery = yield querier.getTxByHash(resp.transactionHash);
        expect(txQuery.isOk()).toBeTruthy();
    }));
});
//# sourceMappingURL=txClient.test.js.map