"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const stargate_1 = require("@cosmjs/stargate");
const long_1 = __importDefault(require("long"));
const cross_fetch_1 = require("cross-fetch");
const __1 = require("..");
describe("connections", () => {
    test("query command is able to fetch latest block", () => __awaiter(void 0, void 0, void 0, function* () {
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const blockResp = yield querier.getBlock();
        (0, __1.assertValidBlock)(blockResp, __1.Localnet);
    }));
    test("tendermint rpc url returns block with GET", () => __awaiter(void 0, void 0, void 0, function* () {
        const resp = yield (0, cross_fetch_1.fetch)(`${__1.Localnet.endptTm}/block`);
        const respJson = (yield resp.json());
        expect(respJson.result).toHaveProperty("block");
        const blockJson = respJson.result.block;
        (0, __1.assertValidBlockFromJsonRpc)(blockJson);
    }));
});
describe("x/bank queries", () => {
    test("query bank balance", () => __awaiter(void 0, void 0, void 0, function* () {
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const balances = yield querier.getAllBalances(__1.TEST_ADDRESS);
        expect(balances.length).toBeGreaterThan(0);
        const amount = +balances[0].amount;
        expect(amount).toBeGreaterThan(0);
        expect(balances[0].denom).not.toBe("");
        const balanceDenoms = balances.map((coin) => coin.denom);
        expect(balanceDenoms).toContain("unibi");
    }));
});
describe("x/oracle queries", () => {
    test("query active oracles", () => __awaiter(void 0, void 0, void 0, function* () {
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const { actives } = yield querier.nibiruExtensions.oracle.actives();
        if (actives.length > 0) {
            const pair = actives[0];
            expect(pair).toContain(":");
        }
    }));
    test("query oracle params", () => __awaiter(void 0, void 0, void 0, function* () {
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const { params: moduleParams } = yield querier.nibiruExtensions.oracle.params();
        expect(moduleParams).toBeDefined();
        expect(moduleParams === null || moduleParams === void 0 ? void 0 : moduleParams.whitelist.length).toBeGreaterThan(0);
    }));
    test("query exchange rates", () => __awaiter(void 0, void 0, void 0, function* () {
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const exhangeRateMap = yield querier.nibiruExtensions.oracle.exchangeRates();
        if (Object.keys(exhangeRateMap).length > 0) {
            for (const pair in exhangeRateMap.exchangeRates) {
                expect(pair).toBeDefined();
                expect(pair).toEqual(0);
                break;
            }
        }
    }));
});
describe("x/epochs queries", () => {
    const timeoutMs = 8000;
    test("query epochs info and current epoch", () => __awaiter(void 0, void 0, void 0, function* () {
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const infoResp = yield querier.nibiruExtensions.epochs.epochsInfos();
        expect(infoResp).toHaveProperty("epochs");
        expect(infoResp.epochs.length).toBeGreaterThan(0);
        const epochId = infoResp.epochs[0].identifier;
        const currentEpochResp = yield querier.nibiruExtensions.epochs.currentEpoch({
            identifier: epochId,
        });
        expect(long_1.default.isLong(currentEpochResp.currentEpoch)).toBeTruthy();
    }), timeoutMs);
});
describe("x/staking module queries", () => {
    test("query bonded validators", () => __awaiter(void 0, void 0, void 0, function* () {
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const infoResp = yield querier.nibiruExtensions.staking.validators("BOND_STATUS_BONDED");
        expect(infoResp).toHaveProperty("validators");
        expect(infoResp.validators.length).toBeGreaterThan(0);
    }));
});
describe("distribution module queries", () => {
    test("distribution params", () => __awaiter(void 0, void 0, void 0, function* () {
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const resp = yield querier.nibiruExtensions.distribution.params();
        const { params } = resp;
        expect(params).toBeDefined();
        const properties = [
            "communityTax",
            "baseProposerReward",
            "bonusProposerReward",
            "withdrawAddrEnabled",
        ];
        properties.forEach((prop) => {
            expect(params).toHaveProperty(prop);
        });
    }));
});
describe("gov module queries", () => {
    test("gov params", () => __awaiter(void 0, void 0, void 0, function* () {
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const resp = yield querier.nibiruExtensions.gov.params("voting");
        const { votingParams } = resp;
        expect(votingParams).toBeDefined();
        const properties = ["votingPeriod"];
        properties.forEach((prop) => {
            expect(votingParams).toHaveProperty(prop);
        });
    }));
});
describe("ibc module queries", () => {
    test("all channels", () => __awaiter(void 0, void 0, void 0, function* () {
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const resp = yield querier.nibiruExtensions.ibc.channel.allChannels();
        const { channels } = resp;
        expect(channels).toBeDefined();
        const properties = [
            "state",
            "ordering",
            "connectionHops",
            "version",
            "portId",
            "channelId",
            "counterparty",
        ];
        channels.forEach((channel) => {
            properties.forEach((prop) => {
                expect(channel).toHaveProperty(prop);
            });
        });
    }));
    test("all connections", () => __awaiter(void 0, void 0, void 0, function* () {
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const resp = yield querier.nibiruExtensions.ibc.connection.allConnections();
        const { connections } = resp;
        expect(connections).toBeDefined();
        const properties = [
            "id",
            "clientId",
            "versions",
            "state",
            "delayPeriod",
            "counterparty",
        ];
        connections.forEach((connection) => {
            properties.forEach((prop) => {
                expect(connection).toHaveProperty(prop);
            });
        });
    }));
    test("clients params", () => __awaiter(void 0, void 0, void 0, function* () {
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const resp = yield querier.nibiruExtensions.ibc.client.params();
        const { params } = resp;
        expect(params).toBeDefined();
        const properties = ["allowedClients"];
        properties.forEach((prop) => {
            expect(params).toHaveProperty(prop);
        });
    }));
    test("transfer params", () => __awaiter(void 0, void 0, void 0, function* () {
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const resp = yield querier.nibiruExtensions.ibc.transfer.params();
        const { params } = resp;
        expect(params).toBeDefined();
        const properties = ["sendEnabled", "receiveEnabled"];
        properties.forEach((prop) => {
            expect(params).toHaveProperty(prop);
        });
    }));
    test("verified channel", () => __awaiter(void 0, void 0, void 0, function* () {
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const channel = yield querier.nibiruExtensions.ibc.verified.channel.channel("transfer", "channel-0");
        const properties = [
            "state",
            "ordering",
            "counterparty",
            "connectionHops",
            "version",
        ];
        if (channel) {
            properties.forEach((prop) => {
                expect(channel).toHaveProperty(prop);
            });
        }
    }));
});
describe("wasm", () => {
    let codeId = 0;
    let contractAddress = "";
    test("deploy contract", () => __awaiter(void 0, void 0, void 0, function* () {
        // Load wasm binary
        const wasmBinary = fs_1.default.readFileSync("./src/sdk/wasm/cw20_base.wasm");
        // Deploy cw20 contract
        const signer = yield (0, __1.newSignerFromMnemonic)(__1.TEST_MNEMONIC);
        const txClient = yield __1.NibiruTxClient.connectWithSigner(__1.Localnet.endptTm, signer);
        const [{ address: sender }] = yield signer.getAccounts();
        const fee = {
            amount: (0, stargate_1.coins)(55000, "unibi"),
            gas: "2200000",
        };
        const assertHappyPath = () => __awaiter(void 0, void 0, void 0, function* () {
            const uploadRes = yield txClient.wasmClient.upload(sender, wasmBinary, fee);
            codeId = uploadRes.codeId;
            const initRes = yield txClient.wasmClient.instantiate(sender, codeId, {
                name: "Custom CW20 Token",
                symbol: "CWXX",
                decimals: 6,
                initial_balances: [],
            }, "CW20", "auto");
            contractAddress = initRes.contractAddress;
            const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
            testGetCode(querier);
            testGetAllContractState(querier, contractAddress);
        });
        try {
            yield assertHappyPath();
        }
        catch (error) {
            console.log(error);
            const okErrors = ["account sequence mismatch"];
            (0, __1.assertExpectedError)(error, okErrors);
        }
    }));
    const testGetCode = (querier) => __awaiter(void 0, void 0, void 0, function* () {
        const respGetCode = yield querier.nibiruExtensions.wasm.getCode(codeId);
        const { data } = respGetCode;
        expect(data).toBeDefined();
    });
    const testGetAllContractState = (querier, contractAddress) => __awaiter(void 0, void 0, void 0, function* () {
        const respContractState = yield querier.nibiruExtensions.wasm.getAllContractState(contractAddress);
        const { models } = respContractState;
        expect(models).toBeDefined();
    });
});
describe("auth", () => {
    test("account", () => __awaiter(void 0, void 0, void 0, function* () {
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const res = yield querier.nibiruExtensions.auth.account(__1.TEST_ADDRESS);
        expect(res).toBeDefined();
    }));
});
describe("NibiruQuerier", () => {
    test("waitForHeight", () => __awaiter(void 0, void 0, void 0, function* () {
        jest.useFakeTimers();
        const setTimeoutSpy = jest.spyOn(global, "setTimeout");
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        yield querier.waitForHeight((yield querier.getHeight()) - 1);
        expect(setTimeoutSpy).not.toHaveBeenCalled();
    }));
    // test("waitForNextBlock", async () => {
    //   const setTimeoutSpy = jest.spyOn(global, "setTimeout")
    //   const querier = await NibiruQuerier.connect(Localnet.endptTm)
    //   await querier.waitForNextBlock()
    //   expect(setTimeoutSpy).toHaveBeenCalled()
    // })
    test("getTxByHash - tx doesn't exist", () => __awaiter(void 0, void 0, void 0, function* () {
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const result = yield querier.getTxByHash("7A919F2CC9A51B139444F7D8E84A46EEF307E839C6CA914C1A1C594FEF5C1562");
        expect(result.isErr()).toEqual(true);
    }));
    test("getTxByHash - wrong hash", () => __awaiter(void 0, void 0, void 0, function* () {
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const result = yield querier.getTxByHash("mock");
        expect(result.ok).toEqual(undefined);
    }));
    test("getTxByHash", () => __awaiter(void 0, void 0, void 0, function* () {
        const querier = yield __1.NibiruQuerier.connect(__1.Localnet.endptTm);
        const result = yield querier.getTxByHashBytes(Uint8Array.from([
            193, 113, 231, 87, 170, 14, 237, 180, 87, 3, 220, 115, 58, 146, 22, 42,
            36, 19, 202, 26, 207, 206, 143, 187, 169, 18, 160, 185, 240, 17, 34,
            193,
        ]));
        expect(result.isErr()).toEqual(true);
    }));
});
//# sourceMappingURL=query.test.js.map