"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NibiruQuerier = void 0;
const stargate_1 = require("@cosmjs/stargate");
const tendermint_rpc_1 = require("@cosmjs/tendermint-rpc");
const cosmwasm_stargate_1 = require("@cosmjs/cosmwasm-stargate");
const __1 = require("..");
const tokenfactory_1 = require("./tokenfactory");
/** Querier for a Nibiru network.
 * @example
 * import { NibiruQuerier, Tesnet } from "@nibiruchain/nibijs"
 * const chain = Testnet()
 * const querier = await NibiruQuerier.connect(chain.endptTm)
 * */
class NibiruQuerier extends stargate_1.StargateClient {
    static connect(endpoint, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const tmClient = yield tendermint_rpc_1.Tendermint37Client.connect(endpoint);
            const wasmClient = yield cosmwasm_stargate_1.CosmWasmClient.connect(endpoint);
            return new NibiruQuerier(tmClient, options, wasmClient);
        });
    }
    constructor(tmClient, options, wasmClient) {
        super(tmClient, options);
        /** getTxByHash: Query a transaction (tx) using its hexadecial encoded tx hash.
         * A tx hash uniquely identifies a tx on the blockchain.
         *
         * The hex-encoded tx hash is:
         * - An unambiguous representation of the SHA-256 cryptographic hash in the
         *   consensus layer.
         * - Well-suited for human-facing applications, as it is easier to work with
         *   than bytes.
         *
         * @example
         * const txHash = "7A919F2CC9A51B139444F7D8E84A46EEF307E839C6CA914C1A1C594FEF5C1562"
         * const txRespResult = await getTxByHash(txHash)
         * */
        this.getTxByHash = (txHashHex) => __1.Result.ofSafeExecAsync(() => __awaiter(this, void 0, void 0, function* () {
            const resBz = (0, __1.hexToBytes)(txHashHex);
            if (resBz.ok) {
                return this.tm.tx({ hash: resBz.ok });
            }
            throw resBz.err;
        }));
        /** getTxByHashBytes: Query a transaction (tx) using its SHA-256 tx hash (bytes).
         * A tx hash uniquely identifies a tx on the blockchain.
         *
         * @see getTxByHash - Equivalent query using the hex-encoded tx hash string.
         * */
        this.getTxByHashBytes = (txHash) => __1.Result.ofSafeExecAsync(() => __awaiter(this, void 0, void 0, function* () {
            (0, __1.bytesToHex)(txHash); // To validate the format up-front before making an
            // unnecessary request
            return this.tm.tx({ hash: txHash });
        }));
        this.wasmClient = wasmClient;
        // Because the StargateQueryClient doesn't include methods from the TM client
        this.tm = tmClient;
        this.nibiruExtensions = stargate_1.QueryClient.withExtensions(tmClient, __1.setupDevgasExtension, __1.setupEpochsExtension, __1.setupOracleExtension, __1.setupSudoExtension, __1.setupInflationExtension, stargate_1.setupDistributionExtension, stargate_1.setupGovExtension, stargate_1.setupStakingExtension, stargate_1.setupIbcExtension, cosmwasm_stargate_1.setupWasmExtension, stargate_1.setupAuthExtension, tokenfactory_1.setupTokenFactoryExtension, __1.setupDevgasMsgExtension, __1.setupInflationMsgExtension, __1.setupOracleMsgExtension, __1.setupSudoMsgExtension, __1.setupTokenFactoryMsgExtension);
    }
    waitForHeight(height) {
        return __awaiter(this, void 0, void 0, function* () {
            while ((yield this.getHeight()) < height) {
                yield new Promise((resolve) => {
                    setTimeout(resolve, 300);
                });
            }
        });
    }
    waitForNextBlock() {
        return __awaiter(this, void 0, void 0, function* () {
            const currentHeight = yield this.getHeight();
            while (currentHeight >= (yield this.getHeight())) {
                yield new Promise((resolve) => {
                    setTimeout(resolve, 300);
                });
            }
        });
    }
}
exports.NibiruQuerier = NibiruQuerier;
//# sourceMappingURL=query.js.map