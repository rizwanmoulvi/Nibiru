"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const long_1 = __importDefault(require("long"));
const query = __importStar(require("../../protojs/nibiru/oracle/v1/query"));
const __1 = require("..");
describe("setupOracleExtension", () => {
    const mockBaseQueryClient = {};
    const mockActivesResponse = { actives: [] };
    const mockAggregatePrevoteResponse = {
        aggregatePrevote: {
            hash: "HASH",
            voter: "VOTER",
            submitBlock: long_1.default.fromNumber(100000),
        },
    };
    const mockAggregateVoteResponse = {
        aggregateVote: {
            exchangeRateTuples: [{ pair: "USD", exchangeRate: "132" }],
            voter: "VOTER",
        },
    };
    const mockAggregateVotesResponse = {
        aggregateVotes: [
            {
                exchangeRateTuples: [{ pair: "USD", exchangeRate: "132" }],
                voter: "VOTER",
            },
        ],
    };
    const mockAggregatePrevotesResponse = {
        aggregatePrevotes: [
            {
                hash: "HASH",
                voter: "VOTER",
                submitBlock: long_1.default.fromNumber(100000),
            },
        ],
    };
    const mockExchangeRateResponse = {
        exchangeRate: "123",
    };
    const mockExchangeRate = (0, __1.fromSdkDec)(mockExchangeRateResponse.exchangeRate);
    const mockExchangeRatesResponse = {
        exchangeRates: [{ pair: "USD", exchangeRate: "132" }],
    };
    const mockFeederDelegationResponse = {
        feederAddr: "feeder-address",
    };
    const mockMissCounterResponse = {
        missCounter: long_1.default.fromNumber(12143),
    };
    const mockParamsResponse = { params: undefined };
    const mockVoteTargetsResponse = {
        voteTargets: ["USD"],
    };
    test("should setup oracle extension correctly", () => {
        const extension = (0, __1.setupOracleExtension)(mockBaseQueryClient);
        expect(extension.oracle).toBeDefined();
        expect(extension.oracle.actives).toBeInstanceOf(Function);
        expect(extension.oracle.aggregatePrevote).toBeInstanceOf(Function);
        expect(extension.oracle.aggregatePrevotes).toBeInstanceOf(Function);
        expect(extension.oracle.aggregateVote).toBeInstanceOf(Function);
        expect(extension.oracle.aggregateVotes).toBeInstanceOf(Function);
        expect(extension.oracle.exchangeRate).toBeInstanceOf(Function);
        expect(extension.oracle.exchangeRates).toBeInstanceOf(Function);
        expect(extension.oracle.feederDelegation).toBeInstanceOf(Function);
        expect(extension.oracle.missCounter).toBeInstanceOf(Function);
        expect(extension.oracle.params).toBeInstanceOf(Function);
        expect(extension.oracle.voteTargets).toBeInstanceOf(Function);
    });
    jest.spyOn(query, "QueryClientImpl").mockReturnValue({
        Actives: jest.fn().mockResolvedValue(mockActivesResponse),
        AggregatePrevote: jest.fn().mockResolvedValue(mockAggregatePrevoteResponse),
        AggregatePrevotes: jest
            .fn()
            .mockResolvedValue(mockAggregatePrevotesResponse),
        AggregateVote: jest.fn().mockResolvedValue(mockAggregateVoteResponse),
        AggregateVotes: jest.fn().mockResolvedValue(mockAggregateVotesResponse),
        ExchangeRate: jest.fn().mockResolvedValue(mockExchangeRateResponse),
        ExchangeRates: jest.fn().mockResolvedValue(mockExchangeRatesResponse),
        FeederDelegation: jest.fn().mockResolvedValue(mockFeederDelegationResponse),
        MissCounter: jest.fn().mockResolvedValue(mockMissCounterResponse),
        Params: jest.fn().mockResolvedValue(mockParamsResponse),
        VoteTargets: jest.fn().mockResolvedValue(mockVoteTargetsResponse),
    });
    describe("oracle.actives", () => {
        test("should call QueryActivesRequest and return the response", () => __awaiter(void 0, void 0, void 0, function* () {
            const queryActiveRequest = jest
                .spyOn(query.QueryActivesRequest, "fromPartial")
                .mockReturnValue({});
            const extension = (0, __1.setupOracleExtension)(mockBaseQueryClient);
            const result = yield extension.oracle.actives();
            expect(queryActiveRequest).toHaveBeenCalledWith({});
            expect(result).toEqual(mockActivesResponse);
        }));
    });
    describe("oracle.aggregatePrevote", () => {
        test("should call QueryAggregatePrevoteRequest and return the response", () => __awaiter(void 0, void 0, void 0, function* () {
            const queryAggregatePrevoteRequest = jest
                .spyOn(query.QueryAggregatePrevoteRequest, "fromPartial")
                .mockReturnValue({});
            const extension = (0, __1.setupOracleExtension)(mockBaseQueryClient);
            const result = yield extension.oracle.aggregatePrevote({
                validatorAddr: "1234567",
            });
            expect(queryAggregatePrevoteRequest).toHaveBeenCalledWith({
                validatorAddr: "1234567",
            });
            expect(result).toEqual(mockAggregatePrevoteResponse);
        }));
    });
    describe("oracle.aggregatePrevotes", () => {
        test("should call QueryAggregatePrevotesRequest and return the response", () => __awaiter(void 0, void 0, void 0, function* () {
            const queryAggregatePrevotesRequest = jest
                .spyOn(query.QueryAggregatePrevotesRequest, "fromPartial")
                .mockReturnValue({});
            const extension = (0, __1.setupOracleExtension)(mockBaseQueryClient);
            const result = yield extension.oracle.aggregatePrevotes();
            expect(queryAggregatePrevotesRequest).toHaveBeenCalledWith({});
            expect(result).toEqual(mockAggregatePrevotesResponse);
        }));
    });
    describe("oracle.aggregateVote", () => {
        test("should call QueryAggregatePrevoteRequest and return the response", () => __awaiter(void 0, void 0, void 0, function* () {
            const queryAggregateVoteRequest = jest
                .spyOn(query.QueryAggregateVoteRequest, "fromPartial")
                .mockReturnValue({});
            const extension = (0, __1.setupOracleExtension)(mockBaseQueryClient);
            const result = yield extension.oracle.aggregateVote({
                validatorAddr: "1234567",
            });
            expect(queryAggregateVoteRequest).toHaveBeenCalledWith({
                validatorAddr: "1234567",
            });
            expect(result).toEqual(mockAggregateVoteResponse);
        }));
    });
    describe("oracle.aggregateVotes", () => {
        test("should call QueryAggregatePrevoteRequest and return the response", () => __awaiter(void 0, void 0, void 0, function* () {
            const queryAggregateVotesRequest = jest
                .spyOn(query.QueryAggregateVotesRequest, "fromPartial")
                .mockReturnValue({});
            const extension = (0, __1.setupOracleExtension)(mockBaseQueryClient);
            const result = yield extension.oracle.aggregateVotes();
            expect(queryAggregateVotesRequest).toHaveBeenCalledWith({});
            expect(result).toEqual(mockAggregateVotesResponse);
        }));
    });
    describe("oracle.exchangeRate", () => {
        test("should call QueryExchangeRateRequest and return the response", () => __awaiter(void 0, void 0, void 0, function* () {
            const queryExchangeRateRequest = jest
                .spyOn(query.QueryExchangeRateRequest, "fromPartial")
                .mockReturnValue({});
            const extension = (0, __1.setupOracleExtension)(mockBaseQueryClient);
            const result = yield extension.oracle.exchangeRate({ pair: "PAIR" });
            expect(queryExchangeRateRequest).toHaveBeenCalledWith({ pair: "PAIR" });
            expect((0, __1.fromSdkDec)(result.exchangeRate)).toEqual(mockExchangeRate);
        }));
    });
    describe("oracle.exchangeRates", () => {
        test("should call QueryExchangeRatesRequest and return the response", () => __awaiter(void 0, void 0, void 0, function* () {
            const queryExchangeRatesRequest = jest
                .spyOn(query.QueryExchangeRatesRequest, "fromPartial")
                .mockReturnValue({});
            const extension = (0, __1.setupOracleExtension)(mockBaseQueryClient);
            const result = yield extension.oracle.exchangeRates();
            expect(queryExchangeRatesRequest).toHaveBeenCalledWith({});
            expect(result.exchangeRates[0]).toEqual({
                exchangeRate: "132",
                pair: "USD",
            });
        }));
    });
    describe("oracle.feeder", () => {
        test("should call QueryFeederDelegationRequest and return the response", () => __awaiter(void 0, void 0, void 0, function* () {
            const queryFeederDelegationRequest = jest
                .spyOn(query.QueryFeederDelegationRequest, "fromPartial")
                .mockReturnValue({});
            const extension = (0, __1.setupOracleExtension)(mockBaseQueryClient);
            const result = yield extension.oracle.feederDelegation({
                validatorAddr: "oracle",
            });
            expect(queryFeederDelegationRequest).toHaveBeenCalledWith({
                validatorAddr: "oracle",
            });
            expect(result).toEqual(mockFeederDelegationResponse);
        }));
    });
    describe("oracle.missCount", () => {
        test("should call QueryMissCounterRequest and return the response", () => __awaiter(void 0, void 0, void 0, function* () {
            const queryMissCounterRequest = jest
                .spyOn(query.QueryMissCounterRequest, "fromPartial")
                .mockReturnValue({});
            const extension = (0, __1.setupOracleExtension)(mockBaseQueryClient);
            const result = yield extension.oracle.missCounter({
                validatorAddr: "oracle",
            });
            expect(queryMissCounterRequest).toHaveBeenCalledWith({
                validatorAddr: "oracle",
            });
            expect(result).toEqual(mockMissCounterResponse);
        }));
    });
    describe("oracle.params", () => {
        test("should call QueryParamsRequest and return the response", () => __awaiter(void 0, void 0, void 0, function* () {
            const queryParamsRequest = jest
                .spyOn(query.QueryParamsRequest, "fromPartial")
                .mockReturnValue({});
            const extension = (0, __1.setupOracleExtension)(mockBaseQueryClient);
            const result = yield extension.oracle.params();
            expect(queryParamsRequest).toHaveBeenCalledWith({});
            expect(result).toEqual(mockParamsResponse);
        }));
    });
    describe("oracle.voteTargets", () => {
        test("should call QueryVoteTargetsRequest and return the response", () => __awaiter(void 0, void 0, void 0, function* () {
            const queryVoteTargetsRequest = jest
                .spyOn(query.QueryVoteTargetsRequest, "fromPartial")
                .mockReturnValue({});
            const extension = (0, __1.setupOracleExtension)(mockBaseQueryClient);
            const result = yield extension.oracle.voteTargets();
            expect(queryVoteTargetsRequest).toHaveBeenCalledWith({});
            expect(result).toEqual(mockVoteTargetsResponse);
        }));
    });
});
//# sourceMappingURL=oracle.test.js.map