import Long from "long";
import _m0 from "protobufjs/minimal";
import { Metadata } from "../../../cosmos/bank/v1beta1/bank";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { ModuleParams } from "./state";
/**
 * MsgCreateDenom: sdk.Msg that registers an a token factory denom.
 * A denom has the form "tf/[creatorAddr]/[subdenom]".
 *  - Denoms become unique x/bank tokens, so the creator-subdenom pair that
 *    defines a denom cannot be reused.
 *  - The resulting denom's admin is originally set to be the creator, but the
 *    admin can be changed later.
 */
export interface MsgCreateDenom {
    sender: string;
    /** subdenom can be up to 44 "alphanumeric" characters long. */
    subdenom: string;
}
/** MsgCreateDenomResponse is the return value of MsgCreateDenom */
export interface MsgCreateDenomResponse {
    /** NewTokenDenom: identifier for the newly created token factory denom. */
    newTokenDenom: string;
}
/**
 * MsgChangeAdmin is the sdk.Msg type for allowing an admin account to change
 * admin of a denom to a new account
 */
export interface MsgChangeAdmin {
    sender: string;
    denom: string;
    newAdmin: string;
}
/** MsgChangeAdminResponse is the gRPC response for the MsgChangeAdmin TxMsg. */
export interface MsgChangeAdminResponse {
}
/** MsgUpdateModuleParams: sdk.Msg for updating the x/tokenfactory module params */
export interface MsgUpdateModuleParams {
    /** Authority: Address of the governance module account. */
    authority: string;
    params?: ModuleParams;
}
/**
 * MsgUpdateModuleParamsResponse is the gRPC response for the
 * MsgUpdateModuleParams TxMsg.
 */
export interface MsgUpdateModuleParamsResponse {
}
/** MsgMint: sdk.Msg (TxMsg) where an denom admin mints more of the token. */
export interface MsgMint {
    sender: string;
    /** coin: The denom identifier and amount to mint. */
    coin?: Coin;
    /**
     * mint_to_addr: An address to which tokens will be minted. If blank,
     * tokens are minted to the "sender".
     */
    mintTo: string;
}
export interface MsgMintResponse {
    mintTo: string;
}
/**
 * MsgBurn: sdk.Msg (TxMsg) where a denom admin burns some of the token.
 * The reason that the sender isn't automatically the "burn_from" address
 * is to support smart contracts (primary use case). In this situation, the
 * contract is the message signer and sender, while "burn_from" is based on the
 * contract logic.
 */
export interface MsgBurn {
    sender: string;
    /** coin: The denom identifier and amount to burn. */
    coin?: Coin;
    /** burn_from: The address from which tokens will be burned. */
    burnFrom: string;
}
export interface MsgBurnResponse {
}
/**
 * MsgSetDenomMetadata: sdk.Msg (TxMsg) enabling the denom admin to change its
 * bank metadata.
 */
export interface MsgSetDenomMetadata {
    sender: string;
    /**
     * Metadata: Official x/bank metadata for the denom. All token factory denoms
     * are standard, native assets. The "metadata.base" is the denom.
     */
    metadata?: Metadata;
}
export interface MsgSetDenomMetadataResponse {
}
/** Burn a native token such as unibi */
export interface MsgBurnNative {
    sender: string;
    coin?: Coin;
}
export interface MsgBurnNativeResponse {
}
export declare const MsgCreateDenom: {
    encode(message: MsgCreateDenom, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateDenom;
    fromJSON(object: any): MsgCreateDenom;
    toJSON(message: MsgCreateDenom): unknown;
    create<I extends {
        sender?: string | undefined;
        subdenom?: string | undefined;
    } & {
        sender?: string | undefined;
        subdenom?: string | undefined;
    } & { [K in Exclude<keyof I, keyof MsgCreateDenom>]: never; }>(base?: I | undefined): MsgCreateDenom;
    fromPartial<I_1 extends {
        sender?: string | undefined;
        subdenom?: string | undefined;
    } & {
        sender?: string | undefined;
        subdenom?: string | undefined;
    } & { [K_1 in Exclude<keyof I_1, keyof MsgCreateDenom>]: never; }>(object: I_1): MsgCreateDenom;
};
export declare const MsgCreateDenomResponse: {
    encode(message: MsgCreateDenomResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateDenomResponse;
    fromJSON(object: any): MsgCreateDenomResponse;
    toJSON(message: MsgCreateDenomResponse): unknown;
    create<I extends {
        newTokenDenom?: string | undefined;
    } & {
        newTokenDenom?: string | undefined;
    } & { [K in Exclude<keyof I, "newTokenDenom">]: never; }>(base?: I | undefined): MsgCreateDenomResponse;
    fromPartial<I_1 extends {
        newTokenDenom?: string | undefined;
    } & {
        newTokenDenom?: string | undefined;
    } & { [K_1 in Exclude<keyof I_1, "newTokenDenom">]: never; }>(object: I_1): MsgCreateDenomResponse;
};
export declare const MsgChangeAdmin: {
    encode(message: MsgChangeAdmin, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgChangeAdmin;
    fromJSON(object: any): MsgChangeAdmin;
    toJSON(message: MsgChangeAdmin): unknown;
    create<I extends {
        sender?: string | undefined;
        denom?: string | undefined;
        newAdmin?: string | undefined;
    } & {
        sender?: string | undefined;
        denom?: string | undefined;
        newAdmin?: string | undefined;
    } & { [K in Exclude<keyof I, keyof MsgChangeAdmin>]: never; }>(base?: I | undefined): MsgChangeAdmin;
    fromPartial<I_1 extends {
        sender?: string | undefined;
        denom?: string | undefined;
        newAdmin?: string | undefined;
    } & {
        sender?: string | undefined;
        denom?: string | undefined;
        newAdmin?: string | undefined;
    } & { [K_1 in Exclude<keyof I_1, keyof MsgChangeAdmin>]: never; }>(object: I_1): MsgChangeAdmin;
};
export declare const MsgChangeAdminResponse: {
    encode(_: MsgChangeAdminResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgChangeAdminResponse;
    fromJSON(_: any): MsgChangeAdminResponse;
    toJSON(_: MsgChangeAdminResponse): unknown;
    create<I extends {} & {} & { [K in Exclude<keyof I, never>]: never; }>(base?: I | undefined): MsgChangeAdminResponse;
    fromPartial<I_1 extends {} & {} & { [K_1 in Exclude<keyof I_1, never>]: never; }>(_: I_1): MsgChangeAdminResponse;
};
export declare const MsgUpdateModuleParams: {
    encode(message: MsgUpdateModuleParams, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateModuleParams;
    fromJSON(object: any): MsgUpdateModuleParams;
    toJSON(message: MsgUpdateModuleParams): unknown;
    create<I extends {
        authority?: string | undefined;
        params?: {
            denomCreationGasConsume?: string | number | Long | undefined;
        } | undefined;
    } & {
        authority?: string | undefined;
        params?: ({
            denomCreationGasConsume?: string | number | Long | undefined;
        } & {
            denomCreationGasConsume?: string | number | (Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long) => Long;
                and: (other: string | number | Long) => Long;
                compare: (other: string | number | Long) => number;
                comp: (other: string | number | Long) => number;
                divide: (divisor: string | number | Long) => Long;
                div: (divisor: string | number | Long) => Long;
                equals: (other: string | number | Long) => boolean;
                eq: (other: string | number | Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long) => boolean;
                gt: (other: string | number | Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long) => boolean;
                gte: (other: string | number | Long) => boolean;
                ge: (other: string | number | Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | Long) => boolean;
                lt: (other: string | number | Long) => boolean;
                lessThanOrEqual: (other: string | number | Long) => boolean;
                lte: (other: string | number | Long) => boolean;
                le: (other: string | number | Long) => boolean;
                modulo: (other: string | number | Long) => Long;
                mod: (other: string | number | Long) => Long;
                rem: (other: string | number | Long) => Long;
                multiply: (multiplier: string | number | Long) => Long;
                mul: (multiplier: string | number | Long) => Long;
                negate: () => Long;
                neg: () => Long;
                not: () => Long;
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | Long) => boolean;
                neq: (other: string | number | Long) => boolean;
                ne: (other: string | number | Long) => boolean;
                or: (other: string | number | Long) => Long;
                shiftLeft: (numBits: number | Long) => Long;
                shl: (numBits: number | Long) => Long;
                shiftRight: (numBits: number | Long) => Long;
                shr: (numBits: number | Long) => Long;
                shiftRightUnsigned: (numBits: number | Long) => Long;
                shru: (numBits: number | Long) => Long;
                shr_u: (numBits: number | Long) => Long;
                rotateLeft: (numBits: number | Long) => Long;
                rotl: (numBits: number | Long) => Long;
                rotateRight: (numBits: number | Long) => Long;
                rotr: (numBits: number | Long) => Long;
                subtract: (subtrahend: string | number | Long) => Long;
                sub: (subtrahend: string | number | Long) => Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long;
                xor: (other: string | number | Long) => Long;
            } & { [K in Exclude<keyof I["params"]["denomCreationGasConsume"], keyof Long>]: never; }) | undefined;
        } & { [K_1 in Exclude<keyof I["params"], "denomCreationGasConsume">]: never; }) | undefined;
    } & { [K_2 in Exclude<keyof I, keyof MsgUpdateModuleParams>]: never; }>(base?: I | undefined): MsgUpdateModuleParams;
    fromPartial<I_1 extends {
        authority?: string | undefined;
        params?: {
            denomCreationGasConsume?: string | number | Long | undefined;
        } | undefined;
    } & {
        authority?: string | undefined;
        params?: ({
            denomCreationGasConsume?: string | number | Long | undefined;
        } & {
            denomCreationGasConsume?: string | number | (Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long) => Long;
                and: (other: string | number | Long) => Long;
                compare: (other: string | number | Long) => number;
                comp: (other: string | number | Long) => number;
                divide: (divisor: string | number | Long) => Long;
                div: (divisor: string | number | Long) => Long;
                equals: (other: string | number | Long) => boolean;
                eq: (other: string | number | Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long) => boolean;
                gt: (other: string | number | Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long) => boolean;
                gte: (other: string | number | Long) => boolean;
                ge: (other: string | number | Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                eqz: () => boolean;
                lessThan: (other: string | number | Long) => boolean;
                lt: (other: string | number | Long) => boolean;
                lessThanOrEqual: (other: string | number | Long) => boolean;
                lte: (other: string | number | Long) => boolean;
                le: (other: string | number | Long) => boolean;
                modulo: (other: string | number | Long) => Long;
                mod: (other: string | number | Long) => Long;
                rem: (other: string | number | Long) => Long;
                multiply: (multiplier: string | number | Long) => Long;
                mul: (multiplier: string | number | Long) => Long;
                negate: () => Long;
                neg: () => Long;
                not: () => Long;
                countLeadingZeros: () => number;
                clz: () => number;
                countTrailingZeros: () => number;
                ctz: () => number;
                notEquals: (other: string | number | Long) => boolean;
                neq: (other: string | number | Long) => boolean;
                ne: (other: string | number | Long) => boolean;
                or: (other: string | number | Long) => Long;
                shiftLeft: (numBits: number | Long) => Long;
                shl: (numBits: number | Long) => Long;
                shiftRight: (numBits: number | Long) => Long;
                shr: (numBits: number | Long) => Long;
                shiftRightUnsigned: (numBits: number | Long) => Long;
                shru: (numBits: number | Long) => Long;
                shr_u: (numBits: number | Long) => Long;
                rotateLeft: (numBits: number | Long) => Long;
                rotl: (numBits: number | Long) => Long;
                rotateRight: (numBits: number | Long) => Long;
                rotr: (numBits: number | Long) => Long;
                subtract: (subtrahend: string | number | Long) => Long;
                sub: (subtrahend: string | number | Long) => Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long;
                xor: (other: string | number | Long) => Long;
            } & { [K_3 in Exclude<keyof I_1["params"]["denomCreationGasConsume"], keyof Long>]: never; }) | undefined;
        } & { [K_4 in Exclude<keyof I_1["params"], "denomCreationGasConsume">]: never; }) | undefined;
    } & { [K_5 in Exclude<keyof I_1, keyof MsgUpdateModuleParams>]: never; }>(object: I_1): MsgUpdateModuleParams;
};
export declare const MsgUpdateModuleParamsResponse: {
    encode(_: MsgUpdateModuleParamsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateModuleParamsResponse;
    fromJSON(_: any): MsgUpdateModuleParamsResponse;
    toJSON(_: MsgUpdateModuleParamsResponse): unknown;
    create<I extends {} & {} & { [K in Exclude<keyof I, never>]: never; }>(base?: I | undefined): MsgUpdateModuleParamsResponse;
    fromPartial<I_1 extends {} & {} & { [K_1 in Exclude<keyof I_1, never>]: never; }>(_: I_1): MsgUpdateModuleParamsResponse;
};
export declare const MsgMint: {
    encode(message: MsgMint, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgMint;
    fromJSON(object: any): MsgMint;
    toJSON(message: MsgMint): unknown;
    create<I extends {
        sender?: string | undefined;
        coin?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        mintTo?: string | undefined;
    } & {
        sender?: string | undefined;
        coin?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & { [K in Exclude<keyof I["coin"], keyof Coin>]: never; }) | undefined;
        mintTo?: string | undefined;
    } & { [K_1 in Exclude<keyof I, keyof MsgMint>]: never; }>(base?: I | undefined): MsgMint;
    fromPartial<I_1 extends {
        sender?: string | undefined;
        coin?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        mintTo?: string | undefined;
    } & {
        sender?: string | undefined;
        coin?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & { [K_2 in Exclude<keyof I_1["coin"], keyof Coin>]: never; }) | undefined;
        mintTo?: string | undefined;
    } & { [K_3 in Exclude<keyof I_1, keyof MsgMint>]: never; }>(object: I_1): MsgMint;
};
export declare const MsgMintResponse: {
    encode(message: MsgMintResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgMintResponse;
    fromJSON(object: any): MsgMintResponse;
    toJSON(message: MsgMintResponse): unknown;
    create<I extends {
        mintTo?: string | undefined;
    } & {
        mintTo?: string | undefined;
    } & { [K in Exclude<keyof I, "mintTo">]: never; }>(base?: I | undefined): MsgMintResponse;
    fromPartial<I_1 extends {
        mintTo?: string | undefined;
    } & {
        mintTo?: string | undefined;
    } & { [K_1 in Exclude<keyof I_1, "mintTo">]: never; }>(object: I_1): MsgMintResponse;
};
export declare const MsgBurn: {
    encode(message: MsgBurn, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgBurn;
    fromJSON(object: any): MsgBurn;
    toJSON(message: MsgBurn): unknown;
    create<I extends {
        sender?: string | undefined;
        coin?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        burnFrom?: string | undefined;
    } & {
        sender?: string | undefined;
        coin?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & { [K in Exclude<keyof I["coin"], keyof Coin>]: never; }) | undefined;
        burnFrom?: string | undefined;
    } & { [K_1 in Exclude<keyof I, keyof MsgBurn>]: never; }>(base?: I | undefined): MsgBurn;
    fromPartial<I_1 extends {
        sender?: string | undefined;
        coin?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        burnFrom?: string | undefined;
    } & {
        sender?: string | undefined;
        coin?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & { [K_2 in Exclude<keyof I_1["coin"], keyof Coin>]: never; }) | undefined;
        burnFrom?: string | undefined;
    } & { [K_3 in Exclude<keyof I_1, keyof MsgBurn>]: never; }>(object: I_1): MsgBurn;
};
export declare const MsgBurnResponse: {
    encode(_: MsgBurnResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgBurnResponse;
    fromJSON(_: any): MsgBurnResponse;
    toJSON(_: MsgBurnResponse): unknown;
    create<I extends {} & {} & { [K in Exclude<keyof I, never>]: never; }>(base?: I | undefined): MsgBurnResponse;
    fromPartial<I_1 extends {} & {} & { [K_1 in Exclude<keyof I_1, never>]: never; }>(_: I_1): MsgBurnResponse;
};
export declare const MsgSetDenomMetadata: {
    encode(message: MsgSetDenomMetadata, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgSetDenomMetadata;
    fromJSON(object: any): MsgSetDenomMetadata;
    toJSON(message: MsgSetDenomMetadata): unknown;
    create<I extends {
        sender?: string | undefined;
        metadata?: {
            description?: string | undefined;
            denomUnits?: {
                denom?: string | undefined;
                exponent?: number | undefined;
                aliases?: string[] | undefined;
            }[] | undefined;
            base?: string | undefined;
            display?: string | undefined;
            name?: string | undefined;
            symbol?: string | undefined;
            uri?: string | undefined;
            uriHash?: string | undefined;
        } | undefined;
    } & {
        sender?: string | undefined;
        metadata?: ({
            description?: string | undefined;
            denomUnits?: {
                denom?: string | undefined;
                exponent?: number | undefined;
                aliases?: string[] | undefined;
            }[] | undefined;
            base?: string | undefined;
            display?: string | undefined;
            name?: string | undefined;
            symbol?: string | undefined;
            uri?: string | undefined;
            uriHash?: string | undefined;
        } & {
            description?: string | undefined;
            denomUnits?: ({
                denom?: string | undefined;
                exponent?: number | undefined;
                aliases?: string[] | undefined;
            }[] & ({
                denom?: string | undefined;
                exponent?: number | undefined;
                aliases?: string[] | undefined;
            } & {
                denom?: string | undefined;
                exponent?: number | undefined;
                aliases?: (string[] & string[] & { [K in Exclude<keyof I["metadata"]["denomUnits"][number]["aliases"], keyof string[]>]: never; }) | undefined;
            } & { [K_1 in Exclude<keyof I["metadata"]["denomUnits"][number], keyof import("../../../cosmos/bank/v1beta1/bank").DenomUnit>]: never; })[] & { [K_2 in Exclude<keyof I["metadata"]["denomUnits"], keyof {
                denom?: string | undefined;
                exponent?: number | undefined;
                aliases?: string[] | undefined;
            }[]>]: never; }) | undefined;
            base?: string | undefined;
            display?: string | undefined;
            name?: string | undefined;
            symbol?: string | undefined;
            uri?: string | undefined;
            uriHash?: string | undefined;
        } & { [K_3 in Exclude<keyof I["metadata"], keyof Metadata>]: never; }) | undefined;
    } & { [K_4 in Exclude<keyof I, keyof MsgSetDenomMetadata>]: never; }>(base?: I | undefined): MsgSetDenomMetadata;
    fromPartial<I_1 extends {
        sender?: string | undefined;
        metadata?: {
            description?: string | undefined;
            denomUnits?: {
                denom?: string | undefined;
                exponent?: number | undefined;
                aliases?: string[] | undefined;
            }[] | undefined;
            base?: string | undefined;
            display?: string | undefined;
            name?: string | undefined;
            symbol?: string | undefined;
            uri?: string | undefined;
            uriHash?: string | undefined;
        } | undefined;
    } & {
        sender?: string | undefined;
        metadata?: ({
            description?: string | undefined;
            denomUnits?: {
                denom?: string | undefined;
                exponent?: number | undefined;
                aliases?: string[] | undefined;
            }[] | undefined;
            base?: string | undefined;
            display?: string | undefined;
            name?: string | undefined;
            symbol?: string | undefined;
            uri?: string | undefined;
            uriHash?: string | undefined;
        } & {
            description?: string | undefined;
            denomUnits?: ({
                denom?: string | undefined;
                exponent?: number | undefined;
                aliases?: string[] | undefined;
            }[] & ({
                denom?: string | undefined;
                exponent?: number | undefined;
                aliases?: string[] | undefined;
            } & {
                denom?: string | undefined;
                exponent?: number | undefined;
                aliases?: (string[] & string[] & { [K_5 in Exclude<keyof I_1["metadata"]["denomUnits"][number]["aliases"], keyof string[]>]: never; }) | undefined;
            } & { [K_6 in Exclude<keyof I_1["metadata"]["denomUnits"][number], keyof import("../../../cosmos/bank/v1beta1/bank").DenomUnit>]: never; })[] & { [K_7 in Exclude<keyof I_1["metadata"]["denomUnits"], keyof {
                denom?: string | undefined;
                exponent?: number | undefined;
                aliases?: string[] | undefined;
            }[]>]: never; }) | undefined;
            base?: string | undefined;
            display?: string | undefined;
            name?: string | undefined;
            symbol?: string | undefined;
            uri?: string | undefined;
            uriHash?: string | undefined;
        } & { [K_8 in Exclude<keyof I_1["metadata"], keyof Metadata>]: never; }) | undefined;
    } & { [K_9 in Exclude<keyof I_1, keyof MsgSetDenomMetadata>]: never; }>(object: I_1): MsgSetDenomMetadata;
};
export declare const MsgSetDenomMetadataResponse: {
    encode(_: MsgSetDenomMetadataResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgSetDenomMetadataResponse;
    fromJSON(_: any): MsgSetDenomMetadataResponse;
    toJSON(_: MsgSetDenomMetadataResponse): unknown;
    create<I extends {} & {} & { [K in Exclude<keyof I, never>]: never; }>(base?: I | undefined): MsgSetDenomMetadataResponse;
    fromPartial<I_1 extends {} & {} & { [K_1 in Exclude<keyof I_1, never>]: never; }>(_: I_1): MsgSetDenomMetadataResponse;
};
export declare const MsgBurnNative: {
    encode(message: MsgBurnNative, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgBurnNative;
    fromJSON(object: any): MsgBurnNative;
    toJSON(message: MsgBurnNative): unknown;
    create<I extends {
        sender?: string | undefined;
        coin?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
    } & {
        sender?: string | undefined;
        coin?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & { [K in Exclude<keyof I["coin"], keyof Coin>]: never; }) | undefined;
    } & { [K_1 in Exclude<keyof I, keyof MsgBurnNative>]: never; }>(base?: I | undefined): MsgBurnNative;
    fromPartial<I_1 extends {
        sender?: string | undefined;
        coin?: {
            denom?: string | undefined;
            amount?: string | undefined;
        } | undefined;
    } & {
        sender?: string | undefined;
        coin?: ({
            denom?: string | undefined;
            amount?: string | undefined;
        } & {
            denom?: string | undefined;
            amount?: string | undefined;
        } & { [K_2 in Exclude<keyof I_1["coin"], keyof Coin>]: never; }) | undefined;
    } & { [K_3 in Exclude<keyof I_1, keyof MsgBurnNative>]: never; }>(object: I_1): MsgBurnNative;
};
export declare const MsgBurnNativeResponse: {
    encode(_: MsgBurnNativeResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgBurnNativeResponse;
    fromJSON(_: any): MsgBurnNativeResponse;
    toJSON(_: MsgBurnNativeResponse): unknown;
    create<I extends {} & {} & { [K in Exclude<keyof I, never>]: never; }>(base?: I | undefined): MsgBurnNativeResponse;
    fromPartial<I_1 extends {} & {} & { [K_1 in Exclude<keyof I_1, never>]: never; }>(_: I_1): MsgBurnNativeResponse;
};
/** Msg defines the gRPC Msg service for transactions. */
export interface Msg {
    /** CreateDenom: registers a token factory denom. */
    CreateDenom(request: MsgCreateDenom): Promise<MsgCreateDenomResponse>;
    ChangeAdmin(request: MsgChangeAdmin): Promise<MsgChangeAdminResponse>;
    /**
     * UpdateModuleParams: A governance operation for updating the x/tokenfactory
     * module parameters.
     */
    UpdateModuleParams(request: MsgUpdateModuleParams): Promise<MsgUpdateModuleParamsResponse>;
    Mint(request: MsgMint): Promise<MsgMintResponse>;
    Burn(request: MsgBurn): Promise<MsgBurnResponse>;
    SetDenomMetadata(request: MsgSetDenomMetadata): Promise<MsgSetDenomMetadataResponse>;
    /** burns a native token such as unibi */
    BurnNative(request: MsgBurnNative): Promise<MsgBurnNativeResponse>;
}
export declare const MsgServiceName = "nibiru.tokenfactory.v1.Msg";
export declare class MsgClientImpl implements Msg {
    private readonly rpc;
    private readonly service;
    constructor(rpc: Rpc, opts?: {
        service?: string;
    });
    CreateDenom(request: MsgCreateDenom): Promise<MsgCreateDenomResponse>;
    ChangeAdmin(request: MsgChangeAdmin): Promise<MsgChangeAdminResponse>;
    UpdateModuleParams(request: MsgUpdateModuleParams): Promise<MsgUpdateModuleParamsResponse>;
    Mint(request: MsgMint): Promise<MsgMintResponse>;
    Burn(request: MsgBurn): Promise<MsgBurnResponse>;
    SetDenomMetadata(request: MsgSetDenomMetadata): Promise<MsgSetDenomMetadataResponse>;
    BurnNative(request: MsgBurnNative): Promise<MsgBurnNativeResponse>;
}
interface Rpc {
    request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
export {};
//# sourceMappingURL=tx.d.ts.map